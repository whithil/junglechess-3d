<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Selva: O Jogo de Xadrez Animal</title>
    <link rel="icon" type="image/svg+xml" href="logo.svg">

    <!-- PWA Config -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f5132">
    <link rel="apple-touch-icon" href="assets/pwa-icons-png/icon-192x192.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        /* UI em HTML escondida por defeito, ativada apenas no Gameplay */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            flex-direction: column;
            justify-content: space-between;
        }

        #header {
            text-align: center;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), transparent);
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            color: #ffeb3b;
        }

        #status {
            font-size: 18px;
            margin-top: 5px;
            font-weight: bold;
            color: #ffffff;
            display: none;
        }

        #controls {
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            pointer-events: auto;
        }

        /* --- Estilos do Smartphone Drawer (Apps) --- */
        #smartphone {
            position: absolute;
            top: 0;
            left: 20px;
            width: 320px;
            height: 450px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(10px);
            border: 2px solid #6B4226;
            border-top: none;
            border-radius: 0 0 15px 15px;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        #smartphone.closed {
            transform: translateY(calc(-100% + 44px));
        }

        #phone-header {
            background: #6B4226;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            border-radius: 0 0 13px 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .phone-tabs {
            display: flex;
            background: #4A2E15;
        }

        .phone-tab {
            flex: 1;
            padding: 8px 0;
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
        }

        .phone-tab.active {
            color: white;
            border-bottom: 3px solid #ffeb3b;
            background: rgba(255, 255, 255, 0.1);
        }

        .phone-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: none;
            background: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            color: #333;
        }

        .phone-content.active {
            display: block;
        }

        .log-entry {
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .chat-entry {
            margin-bottom: 10px;
            background: white;
            padding: 8px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        @media (max-width: 600px) {
            #smartphone {
                width: calc(100% - 40px);
                height: 350px;
            }
        }

        /* --- Estilos dos Bot√µes XR Nativos (Fix de Sobreposi√ß√£o) --- */
        #xr-container {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            pointer-events: none;
            z-index: 1000;
        }

        /* O !important for√ßa o Flexbox a anular o position:absolute injetado pelo Three.js */
        #xr-container button {
            position: relative !important;
            left: auto !important;
            bottom: auto !important;
            transform: none !important;
            margin: 0 !important;
            pointer-events: auto;
        }

        /* Oculta os que forem marcados como n√£o suportados pelo MutationObserver */
        #xr-container button.unsupported {
            display: none !important;
        }

        /* ------------------------------------------- */

        #ar-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
</head>

<body>
    <div id="ui-container">
        <div id="header">
            <img src="hero.svg" alt="Jungle Chess 3D Logo" style="height: 60px; display: block; margin: 0 auto 10px;">
            <h1 id="gameTitle" style="font-size: 16px; margin: 0;">Jungle Chess 3D</h1>
            <div id="status">Vez do Jogador Verde</div>
        </div>

        <!-- Smartphone Apps Overlay (Gaveta de Cima para Baixo) -->
        <div id="smartphone">
            <div class="phone-tabs">
                <button class="phone-tab" onclick="openPhoneTab('tab-log', this)">‚öîÔ∏è Di√°rio</button>
                <button class="phone-tab" onclick="openPhoneTab('tab-chat', this)">üí¨ Jungle Net</button>
                <button class="phone-tab active" onclick="openPhoneTab('tab-manual', this)">üìñ E-book</button>
            </div>

            <div id="tab-log" class="phone-content"></div>

            <div id="tab-chat" class="phone-content">
                <div style="text-align: center; color: #888; font-style: italic; margin-bottom: 10px;">Conectando √†
                    Jungle Net...</div>
            </div>

            <div id="tab-manual" class="phone-content active">
                <h3 style="margin-top:0; color: #4A2E15;">üìñ Guia R√°pido</h3>
                <ul style="padding-left: 20px; margin-bottom: 0;">
                    <li><b>O Alvo:</b> Entre na ‚õ∫ Toca inimiga para vencer!</li>
                    <li><b>For√ßa:</b> üêò>ü¶Å>üêØ>üêÜ>üê∫>üê∂>üê±>üê≠. O maior ganha.</li>
                    <li><b>O Segredo:</b> O min√∫sculo üê≠ captura o gigante üêò!</li>
                    <li><b>√Ågua üåä:</b> S√≥ o üê≠ entra no rio.</li>
                    <li><b>Salto üí®:</b> ü¶Å e üêØ saltam por cima dos rios (se n√£o houver rato no caminho).</li>
                    <li><b>Armadilha ü™§:</b> Inimigos na sua armadilha viram for√ßa 0! Mate-os com qualquer pe√ßa.</li>
                </ul>
            </div>

            <div id="phone-header" onclick="togglePhone()">
                <span>üì± Apps da Selva</span>
                <span id="phone-toggle-icon">‚ñ≤</span>
            </div>
        </div>
    </div>
    <div id="ar-overlay">Toque na tela para posicionar o tabuleiro</div>

    <script>
        // Fun√ß√µes UI do Smartphone em Global Scope
        let lastUserSelectedTabId = 'tab-manual'; // Default para E-book
        let isChatAutoOpened = false;
        let hasLoggedFirstMove = false; // Controle da primeira jogada para transi√ß√£o E-book -> Di√°rio

        function togglePhone() {
            const phone = document.getElementById('smartphone');
            const icon = document.getElementById('phone-toggle-icon');
            if (phone.classList.contains('closed')) {
                phone.classList.remove('closed');
                icon.innerText = '‚ñ≤';
            } else {
                phone.classList.add('closed');
                icon.innerText = '‚ñº';
            }
        }

        // Adicionado par√¢metro isManual para rastrear o hist√≥rico do usu√°rio
        function openPhoneTab(tabId, btn, isManual = true) {
            document.querySelectorAll('.phone-content').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.phone-tab').forEach(b => b.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            btn.classList.add('active');

            if (isManual) {
                lastUserSelectedTabId = tabId;
                isChatAutoOpened = false; // Usu√°rio tomou controle manual
            }
        }

        // For√ßa a aba do Chat a abrir automaticamente
        function autoOpenChat() {
            const activeTab = document.querySelector('.phone-content.active');
            if (activeTab && activeTab.id !== 'tab-chat') {
                const tabBtnChat = document.querySelectorAll('.phone-tab')[1];
                openPhoneTab('tab-chat', tabBtnChat, false);
                isChatAutoOpened = true; // Marca que foi aberto pelo sistema
            }

            const phone = document.getElementById('smartphone');
            if (phone.classList.contains('closed')) {
                phone.classList.remove('closed');
                document.getElementById('phone-toggle-icon').innerText = '‚ñ≤';
            }
        }

        // Reverte para a aba que o usu√°rio estava usando antes
        function revertFromAutoChat() {
            if (isChatAutoOpened) {
                const tabs = document.querySelectorAll('.phone-tab');
                let targetBtn = tabs[0]; // default: tab-log
                if (lastUserSelectedTabId === 'tab-manual') targetBtn = tabs[2];
                if (lastUserSelectedTabId === 'tab-chat') targetBtn = tabs[1];

                openPhoneTab(lastUserSelectedTabId, targetBtn, false);
                isChatAutoOpened = false;
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { createJungleChessLogo } from './title.js?v=2';
        // ==========================================/
        // I18N DICTIONARY INITIALIZATION
        // ==========================================/
        let i18nData = {};
        const lang = navigator.language.startsWith('pt') ? 'pt-BR' : 'en-US';
        try {
            const res = await fetch(`lang/${lang}.yml`);
            if (res.ok) {
                i18nData = jsyaml.load(await res.text());
            } else {
                const resFb = await fetch(`lang/en-US.yml`);
                i18nData = jsyaml.load(await resFb.text());
            }
        } catch (e) {
            console.warn("I18N Load Error:", e);
        }

        window.i18n = function (path) {
            const keys = path.split('.');
            let val = i18nData;
            for (let k of keys) {
                if (val && val[k] !== undefined) val = val[k];
                else return path; // Return the key path if not found
            }
            return val;
        };

        // DOM Initial Update
        document.getElementById('gameTitle').innerText = window.i18n('ui.about_text').split('\\n')[0];
        const tabs = document.querySelectorAll('.phone-tab');
        if (tabs.length >= 3) {
            tabs[0].innerHTML = `‚öîÔ∏è ${window.i18n('hud.log')}`;
            tabs[1].innerHTML = `üí¨ ${window.i18n('hud.chat')}`;
            tabs[2].innerHTML = `üìñ ${window.i18n('hud.manual')}`;
        }
        const guideList = document.querySelector('#tab-manual ul');
        if (guideList) {
            guideList.innerHTML = '';
            const lines = window.i18n('hud.guide_lines') || [];
            lines.forEach(l => {
                const li = document.createElement('li');
                li.innerHTML = `<b>${l.split(':')[0]}:</b> ${l.split(':').slice(1).join(':')}`;
                guideList.appendChild(li);
            });
        }
        document.querySelector('#tab-manual h3').innerText = `üìñ ${window.i18n('hud.quick_guide')}`;


        // ==========================================/
        // ESTADOS DO JOGO (STATE MACHINE & MULTIPLAYER)
        // ==========================================/
        let currentScene = 'menu'; // 'menu', 'local_menu', 'options', 'about', 'game', 'multiplayer'
        let tipsEnabled = true;
        let restarting = false;
        let isTransitioningCamera = false;
        let hasGameStarted = false;

        let gameMode = 'pvp';
        let myTeamId = 1;
        let isCPUThinking = false;

        let idleTime = 0;
        let lastGossipTime = 0;
        let pendingReplies = [];

        const closeButtons = [];

        // Rota√ß√£o alvo global das texturas para permitir histerese (evitar tremida visual VR)
        let targetSnapAngle = 0;

        // Fun√ß√£o universal para resetar o tempo ocioso e devolver o telefone √† aba original
        function resetIdleTime() {
            idleTime = 0;
            if (window.revertFromAutoChat) window.revertFromAutoChat();
        }

        let peer = null;
        let peerConnection = null;
        let isHost = true;

        let gyroInitialized = false;
        const targetGyroOffset = new THREE.Vector2(0, 0);
        const currentGyroOffset = new THREE.Vector2(0, 0);

        function handleOrientation(e) {
            if (!e.beta || !e.gamma) return;
            let tiltX = e.gamma;
            let tiltY = e.beta - 45;
            tiltX = THREE.MathUtils.clamp(tiltX, -30, 30);
            tiltY = THREE.MathUtils.clamp(tiltY, -30, 30);
            targetGyroOffset.x = (tiltX / 30) * 0.6;
            targetGyroOffset.y = (tiltY / 30) * 0.6;
        }

        // ==========================================/
        // FUN√á√ïES DA UI DO SMARTPHONE & CHAT LOG
        // ==========================================/
        function updateGameTitle(text) {
            document.getElementById('gameTitle').innerText = text;
        }

        function getChessPos(x, y) {
            const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
            return letters[x] + (y + 1);
        }

        function getPieceNickname(pieceData) {
            const pieceName = RANKS[pieceData.rank].name.toLowerCase();
            const colorName = pieceData.team === 0 ? 'red' : 'green';
            const playerNum = pieceData.team === 0 ? '2' : '1';
            return `${pieceName}_${colorName}_${pieceData.rank}${playerNum}`;
        }

        function logBattle(pieceData, startX, startY, endX, endY, capturedPiece) {
            const from = getChessPos(startX, startY);
            const to = getChessPos(endX, endY);
            const emoji = RANKS[pieceData.rank].icon;
            const teamColor = TEAMS[pieceData.team].color;
            let logText = `<span style="color:${teamColor}; font-weight:bold;">${emoji} ${from} ‚ûî ${to}</span>`;
            if (capturedPiece) {
                const capEmoji = RANKS[capturedPiece.rank].icon;
                logText = `<span style="color:${teamColor}; font-weight:bold;">${emoji} ${from} ‚öîÔ∏è ${capEmoji} ${to}</span>`;
            }
            const logDiv = document.getElementById('tab-log');
            logDiv.innerHTML = `<div class="log-entry">${logText}</div>` + logDiv.innerHTML;

            // Salta automaticamente para o Di√°rio na primeira jogada
            if (!window.hasLoggedFirstMove) {
                window.hasLoggedFirstMove = true;
                const activeTab = document.querySelector('.phone-content.active');
                if (activeTab && activeTab.id === 'tab-manual') {
                    const tabBtnLog = document.querySelectorAll('.phone-tab')[0];
                    // Passa 'true' para registar que a partir de agora o Di√°rio √© o alvo principal do jogador
                    window.openPhoneTab('tab-log', tabBtnLog, true);
                }
            }
            if (window.updateVRPhoneScreen) window.updateVRPhoneScreen();
        }

        function logChat(pieceData, text, replyTo = null) {
            const nickname = getPieceNickname(pieceData);
            const teamColor = TEAMS[pieceData.team].color;
            const emoji = RANKS[pieceData.rank].icon;
            const chatDiv = document.getElementById('tab-chat');

            let replyHTML = '';
            if (replyTo) {
                replyHTML = `
                <div style="background: rgba(0,0,0,0.05); border-left: 4px solid ${teamColor}; margin: 2px 0 4px 0; padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #555; line-height: 1.3;">
                    <b style="color: #333;">Replying to @${replyTo.nickname}</b><br>
                    <i>"${replyTo.text}"</i>
                </div>`;
            }

            const entryHTML = `
                <div class="chat-entry">
                    <div style="color:${teamColor}; font-weight:bold; margin-bottom: 2px; font-size: 13px;">${emoji} @${nickname}</div>
                    ${replyHTML}
                    <div style="color:#222; font-weight: 500; font-size: 14px;">${text}</div>
                </div>
            `;

            chatDiv.innerHTML = entryHTML + chatDiv.innerHTML;
            if (window.updateVRPhoneScreen) window.updateVRPhoneScreen();
        }

        // ==========================================/
        // DADOS DO Jogo E REGRAS
        // ==========================================/
        const RANKS = {
            1: { name: "Rato", icon: "üê≠" }, 2: { name: "Gato", icon: "üê±" }, 3: { name: "C√£o", icon: "üê∂" }, 4: { name: "Lobo", icon: "üê∫" },
            5: { name: "Leopardo", icon: "üêÜ" }, 6: { name: "Tigre", icon: "üêØ" }, 7: { name: "Le√£o", icon: "ü¶Å" }, 8: { name: "Elefante", icon: "üêò" }
        };

        const PARTICLE_EMOJIS = {
            1: ['üßÄ', 'üêæ', '‚ú®'], 2: ['üêü', 'üêæ', '‚ú®'], 3: ['ü¶¥', 'üêæ', '‚ú®'], 4: ['üê∫', 'üêæ', '‚ú®'],
            5: ['ü•©', 'üêæ', '‚ú®'], 6: ['ü•©', 'üêæ', '‚ú®'], 7: ['üëë', 'üêæ', '‚ú®'], 8: ['ü•ú', 'üíß', '‚ú®']
        };

        // Removed GOSSIP_TEXTS object, dialogues are now loaded dynamically from I18N YAML files.

        const TEAMS = {
            0: { color: '#E52222', name: "Vermelho" },
            1: { color: '#25A02B', name: "Verde" }
        };

        const BOARD_COLS = 7; const BOARD_ROWS = 9;
        const WATER_TILES = [
            { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 4, y: 3 }, { x: 5, y: 3 },
            { x: 1, y: 4 }, { x: 2, y: 4 }, { x: 4, y: 4 }, { x: 5, y: 4 },
            { x: 1, y: 5 }, { x: 2, y: 5 }, { x: 4, y: 5 }, { x: 5, y: 5 }
        ];
        const TRAPS = [
            { x: 2, y: 0, team: 0 }, { x: 4, y: 0, team: 0 }, { x: 3, y: 1, team: 0 },
            { x: 2, y: 8, team: 1 }, { x: 4, y: 8, team: 1 }, { x: 3, y: 7, team: 1 }
        ];
        const DENS = [{ x: 3, y: 0, team: 0 }, { x: 3, y: 8, team: 1 }];

        const INITIAL_SETUP = [
            { x: 0, y: 0, t: 0, r: 7 }, { x: 6, y: 0, t: 0, r: 6 }, { x: 1, y: 1, t: 0, r: 3 }, { x: 5, y: 1, t: 0, r: 2 },
            { x: 0, y: 2, t: 0, r: 1 }, { x: 2, y: 2, t: 0, r: 5 }, { x: 4, y: 2, t: 0, r: 4 }, { x: 6, y: 2, t: 0, r: 8 },
            { x: 6, y: 8, t: 1, r: 7 }, { x: 0, y: 8, t: 1, r: 6 }, { x: 5, y: 7, t: 1, r: 3 }, { x: 1, y: 7, t: 1, r: 2 },
            { x: 6, y: 6, t: 1, r: 1 }, { x: 4, y: 6, t: 1, r: 5 }, { x: 2, y: 6, t: 1, r: 4 }, { x: 0, y: 6, t: 1, r: 8 }
        ];

        class GameEngine {
            constructor() { this.reset(); }
            reset() {
                this.board = Array(BOARD_COLS).fill(null).map(() => Array(BOARD_ROWS).fill(null));
                this.pieces = [];
                this.currentTurn = 1;
                this.winner = null;
                // Easter Egg
                this.secretTileLeftActive = false;
                this.secretTileRightActive = false;
                this.secretPieceLeft = null;
                this.secretPieceRight = null;
            }
            addPiece(piece) {
                if (piece.gridX === -1 && piece.gridY === 4) this.secretPieceLeft = piece;
                else if (piece.gridX === 7 && piece.gridY === 4) this.secretPieceRight = piece;
                else this.board[piece.gridX][piece.gridY] = piece;
                this.pieces.push(piece);
            }
            getPieceAt(x, y) {
                if (x === -1 && y === 4) return this.secretPieceLeft;
                if (x === 7 && y === 4) return this.secretPieceRight;
                if (x < 0 || x >= BOARD_COLS || y < 0 || y >= BOARD_ROWS) return null;
                return this.board[x][y];
            }
            isWater(x, y) { return WATER_TILES.some(w => w.x === x && w.y === y); }
            isTrap(x, y, team) { return TRAPS.some(t => t.x === x && t.y === y && t.team === team); }
            isDen(x, y, team) { return DENS.some(d => d.x === x && d.y === y && d.team === team); }

            isValidMove(piece, startX, startY, endX, endY) {
                if (this.winner !== null) return false;

                const isLeftSecret = (endX === -1 && endY === 4 && this.secretTileLeftActive);
                const isRightSecret = (endX === 7 && endY === 4 && this.secretTileRightActive);
                if (!isLeftSecret && !isRightSecret) {
                    if (endX < 0 || endX >= BOARD_COLS || endY < 0 || endY >= BOARD_ROWS) return false;
                }
                if (startX === endX && startY === endY) return false;
                if (this.isDen(endX, endY, piece.team)) return false;

                const targetPiece = this.getPieceAt(endX, endY);
                if (targetPiece && targetPiece.team === piece.team) return false;

                const dx = Math.abs(endX - startX), dy = Math.abs(endY - startY);
                const isOrthogonal = (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
                const endIsWater = this.isWater(endX, endY), startIsWater = this.isWater(startX, startY);

                if (isOrthogonal) {
                    if (endIsWater && piece.rank !== 1) return false;
                    return this.validateCapture(piece, targetPiece, startIsWater, endIsWater, endX, endY);
                }

                if ((piece.rank === 6 || piece.rank === 7) && this.isValidJump(startX, startY, endX, endY)) {
                    return this.validateCapture(piece, targetPiece, false, false, endX, endY);
                }
                return false;
            }

            isValidJump(startX, startY, endX, endY) {
                if (this.isWater(endX, endY)) return false;

                const dx = Math.abs(endX - startX), dy = Math.abs(endY - startY);
                if (!((dx > 1 && dy === 0) || (dx === 0 && dy > 1))) return false;
                const minX = Math.min(startX, endX), maxX = Math.max(startX, endX);
                const minY = Math.min(startY, endY), maxY = Math.max(startY, endY);

                if (dy === 0) {
                    for (let x = minX + 1; x < maxX; x++) {
                        if (!this.isWater(x, startY) || this.getPieceAt(x, startY) !== null) return false;
                    }
                    return true;
                } else {
                    for (let y = minY + 1; y < maxY; y++) {
                        if (!this.isWater(startX, y) || this.getPieceAt(startX, y) !== null) return false;
                    }
                    return true;
                }
            }

            validateCapture(piece, targetPiece, startIsWater, endIsWater, endX, endY) {
                if (!targetPiece) return true;
                if (startIsWater !== endIsWater) return false;
                if (this.isTrap(endX, endY, piece.team)) return true;
                if (piece.rank === 1 && targetPiece.rank === 8) return true;
                if (piece.rank === 8 && targetPiece.rank === 1) return false;
                return piece.rank >= targetPiece.rank;
            }

            executeMove(piece, endX, endY) {
                const startX = piece.gridX;
                const startY = piece.gridY;
                const targetPiece = this.getPieceAt(endX, endY);
                let captured = null;

                if (startX === -1 && startY === 4) this.secretPieceLeft = null;
                else if (startX === 7 && startY === 4) this.secretPieceRight = null;
                else this.board[startX][startY] = null;

                if (targetPiece) {
                    captured = targetPiece;
                    this.pieces = this.pieces.filter(p => p !== targetPiece);
                }
                piece.gridX = endX;
                piece.gridY = endY;

                if (endX === -1 && endY === 4) this.secretPieceLeft = piece;
                else if (endX === 7 && endY === 4) this.secretPieceRight = piece;
                else this.board[endX][endY] = piece;

                // Easter egg activation
                if (endX === 0 && endY === 4) this.secretTileLeftActive = true;
                if (endX === 6 && endY === 4) this.secretTileRightActive = true;
                const enemyTeam = piece.team === 0 ? 1 : 0;
                if (this.isDen(endX, endY, enemyTeam) || this.pieces.filter(p => p.team === enemyTeam).length === 0) {
                    this.winner = piece.team;
                }
                this.currentTurn = enemyTeam;

                logBattle(piece, startX, startY, endX, endY, captured);

                return captured;
            }
        }

        const engine = new GameEngine();

        // ==========================================/
        // SISTEMA DE √ÅUDIO ARCADE PROCEDURAL
        // ==========================================/
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function createNoiseBuffer() {
            const bufferSize = audioCtx.sampleRate * 2.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        function playThump(now, buffer) {
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, now);
            filter.frequency.exponentialRampToValueAtTime(40, now + 0.5);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.8, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            source.start(now);
        }

        function playChurn(now, buffer) {
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(1200, now);
            filter.Q.setValueAtTime(2, now);
            filter.frequency.exponentialRampToValueAtTime(300, now + 1.2);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.4, now + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            source.start(now);
        }

        function playSpray(now, buffer) {
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(3000, now);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.2, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 1.8);
            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            source.start(now);
        }

        function playSound(type) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            if (type === 'splash') {
                const buffer = createNoiseBuffer();
                playThump(now, buffer);
                playChurn(now, buffer);
                playSpray(now, buffer);
                return;
            }
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            if (type === 'jump') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(250, now); osc.frequency.exponentialRampToValueAtTime(450, now + 0.2);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'squash') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            } else if (type === 'morph') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.3, now + 0.1); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'beep') {
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'beep-up') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'nervous') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(350, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.1); osc.frequency.linearRampToValueAtTime(380, now + 0.2);
                osc.frequency.linearRampToValueAtTime(300, now + 0.3); osc.frequency.linearRampToValueAtTime(350, now + 0.4);
                gain.gain.setValueAtTime(0.25, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'cheeky') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(500, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'win') {
                osc.type = 'square'; const notes = [261.63, 329.63, 392.00, 523.25, 392.00, 523.25, 659.25, 783.99, 1046.50]; let timeOffset = 0;
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.3, now + 0.05);
                notes.forEach((freq, index) => { osc.frequency.setValueAtTime(freq, now + timeOffset); timeOffset += (index >= notes.length - 2) ? 0.4 : 0.15; });
                gain.gain.setValueAtTime(0.3, now + timeOffset); gain.gain.linearRampToValueAtTime(0, now + timeOffset + 1.5);
                osc.start(now); osc.stop(now + timeOffset + 1.5);
            }
        }

        // ==========================================/
        // THREE.JS SETUP & GR√ÅFICOS
        // ==========================================/
        const scene = new THREE.Scene();
        let bgTexture = null;
        const loader = new THREE.TextureLoader();
        const texture = loader.load(
            'assets/bg2.webp',
            () => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                texture.colorSpace = THREE.SRGBColorSpace;
                bgTexture = texture;
                if (!isARSession) scene.background = bgTexture;
            });
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);

        camera.position.set(0, 7, 8);
        camera.userData = { targetPos: new THREE.Vector3(0, 7, 8) };
        scene.add(camera);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true; renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- SISTEMA INTELIGENTE DE BOT√ïES XR ---
        const xrContainer = document.createElement('div');
        xrContainer.id = 'xr-container';
        document.body.appendChild(xrContainer);

        const vrButton = VRButton.createButton(renderer);
        const arButton = ARButton.createButton(renderer);

        xrContainer.appendChild(vrButton);
        xrContainer.appendChild(arButton);

        const updateXRButtons = () => {
            [vrButton, arButton].forEach(btn => {
                if (btn.textContent.toUpperCase().includes('NOT SUPPORTED')) {
                    btn.classList.add('unsupported');
                } else {
                    btn.classList.remove('unsupported');
                }
            });
        };

        const xrObserver = new MutationObserver(updateXRButtons);
        xrObserver.observe(vrButton, { childList: true, characterData: true, subtree: true });
        xrObserver.observe(arButton, { childList: true, characterData: true, subtree: true });

        updateXRButtons();
        // ----------------------------------------

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0); controls.update();
        controls.userData = { target: new THREE.Vector3(0, 0, 0) };

        // ------------------------------------------
        // SISTEMA DE ILUMINA√á√ÉO SUTIL
        // ------------------------------------------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.45); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(5, 10, 5); dirLight.castShadow = true; scene.add(dirLight);

        const lightRedSide = new THREE.PointLight(0xffffff, 1.8, 15);
        lightRedSide.position.set(0, 2.5, -3.5);
        scene.add(lightRedSide);

        const lightGreenSide = new THREE.PointLight(0xffffff, 1.8, 15);
        lightGreenSide.position.set(0, 2.5, 3.5);
        scene.add(lightGreenSide);

        const auraLight = new THREE.PointLight(0xffffff, 0, 3.0);
        auraLight.position.y = 0.5;
        scene.add(auraLight);

        const gameGroup = new THREE.Group(); scene.add(gameGroup);

        // ==========================================/
        // BANNERS
        // ==========================================/
        const bannerGroup = new THREE.Group();
        gameGroup.add(bannerGroup);

        const pieceHeight = 0.6;

        function createBannerClothTexture(team) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 768;
            const ctx = canvas.getContext('2d');

            const teamColor = new THREE.Color(TEAMS[team].color);
            const color1 = teamColor.clone().multiplyScalar(0.8).getStyle();
            const color2 = teamColor.clone().multiplyScalar(1.2).getStyle();

            const size = 128;
            for (let x = 0; x < canvas.width; x += size) {
                for (let y = 0; y < canvas.height; y += size) {
                    ctx.fillStyle = ((x / size + y / size) % 2 === 0) ? color1 : color2;
                    ctx.fillRect(x, y, size, size);
                }
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 8;
            ctx.font = 'bold 90px sans-serif';
            ctx.strokeText("PLAYER", 256, 180);
            ctx.fillText("PLAYER", 256, 180);

            const num = team === 1 ? "1" : "2";
            ctx.lineWidth = 20;
            ctx.font = 'bold 450px sans-serif';
            ctx.strokeText(num, 256, 520);
            ctx.fillText(num, 256, 520);

            return new THREE.CanvasTexture(canvas);
        }

        function createBanner(team) {
            const banner = new THREE.Group();
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });

            const bannerHeight = pieceHeight * 3;
            const poleHeight = bannerHeight * 1.5;
            const crossbarWidth = bannerHeight / 1.5;

            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, poleHeight, 8);
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = poleHeight / 2;
            banner.add(pole);

            const crossbarGeo = new THREE.CylinderGeometry(0.04, 0.04, crossbarWidth, 8);
            const crossbar = new THREE.Mesh(crossbarGeo, poleMat);
            crossbar.rotation.z = Math.PI / 2;
            crossbar.position.set(crossbarWidth / 2, poleHeight - 0.1, 0);
            banner.add(crossbar);

            const clothGeo = new THREE.BoxGeometry(crossbarWidth, bannerHeight, 0.01, 10, 15, 1);
            clothGeo.translate(0, -bannerHeight / 2, 0);

            const teamColor = new THREE.Color(TEAMS[team].color);
            const color1 = teamColor.clone().multiplyScalar(0.8).getStyle();

            const clothFaceMat = new THREE.MeshStandardMaterial({
                map: createBannerClothTexture(team),
                roughness: 0.9,
                metalness: 0.1,
            });

            const edgeMat = new THREE.MeshStandardMaterial({
                color: color1,
                roughness: 0.9,
                metalness: 0.1,
            });

            const materials = [edgeMat, edgeMat, edgeMat, edgeMat, clothFaceMat, clothFaceMat];

            const cloth = new THREE.Mesh(clothGeo, materials);
            cloth.position.set(crossbarWidth / 2, poleHeight - 0.1, 0);
            banner.add(cloth);

            cloth.userData.originalVertices = [];
            const posAttr = cloth.geometry.attributes.position;
            for (let i = 0; i < posAttr.count; i++) {
                cloth.userData.originalVertices.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
            }

            return { banner, cloth };
        }

        const bannerRed = createBanner(0);
        bannerRed.banner.position.set(-3.55, -0.1, -4.55);
        bannerRed.banner.rotation.y = Math.PI;
        bannerGroup.add(bannerRed.banner);

        const bannerGreen = createBanner(1);
        bannerGreen.banner.position.set(3.55, -0.1, 4.55);
        bannerGroup.add(bannerGreen.banner);

        // ==========================================/
        // MOLDURA DE MADEIRA PARA OS MENUS
        // ==========================================/
        function createMenuPanel(width, height, posY) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#E69545';
            ctx.fillRect(0, 0, 512, 512);

            ctx.strokeStyle = '#CC7A33';
            ctx.lineWidth = 5;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * 512);
                ctx.bezierCurveTo(170, Math.random() * 512, 340, Math.random() * 512, 512, Math.random() * 512);
                ctx.stroke();
            }

            ctx.strokeStyle = '#4A2E15';
            ctx.lineWidth = 40;
            ctx.strokeRect(0, 0, 512, 512);

            ctx.strokeStyle = 'rgba(0,0,0,0.4)';
            ctx.lineWidth = 10;
            ctx.strokeRect(20, 20, 472, 472);

            const faceMat = new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(canvas), roughness: 0.9 });
            const edgeMat = new THREE.MeshStandardMaterial({ color: '#4A2E15', roughness: 0.9 });

            const geo = new THREE.BoxGeometry(width, height, 0.1);
            const materials = [edgeMat, edgeMat, edgeMat, edgeMat, faceMat, faceMat];
            const mesh = new THREE.Mesh(geo, materials);

            mesh.position.set(0, posY, -0.15);
            return mesh;
        }

        // ==========================================/
        // SISTEMA DE CENAS E UI 3D (MENUS)
        // ==========================================/
        const menuGroup = new THREE.Group(); gameGroup.add(menuGroup);
        const localMenuGroup = new THREE.Group(); gameGroup.add(localMenuGroup);
        const optionsGroup = new THREE.Group(); gameGroup.add(optionsGroup);
        const aboutGroup = new THREE.Group(); gameGroup.add(aboutGroup);
        const multiplayerGroup = new THREE.Group(); gameGroup.add(multiplayerGroup);

        menuGroup.position.set(0, 2.5, 0);
        localMenuGroup.position.set(0, 2.5, 0);
        optionsGroup.position.set(0, 2.5, 0);
        aboutGroup.position.set(0, 2.5, 0);
        multiplayerGroup.position.set(0, 2.5, 0);

        function createTextSprite(text, fontSize, width, height, color = 'white', bgColor = 'transparent') {
            const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            if (bgColor !== 'transparent') {
                ctx.fillStyle = bgColor;
                if (ctx.roundRect) ctx.roundRect(10, 10, width - 20, height - 20, 30); else ctx.fillRect(10, 10, width - 20, height - 20);
                ctx.fill(); ctx.lineWidth = 6; ctx.strokeStyle = '#000000'; ctx.stroke();
            }
            ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `bold ${fontSize}px sans-serif`;
            const lines = text.split('\n');
            lines.forEach((line, i) => { ctx.fillText(line, width / 2, height / 2 + (i - (lines.length - 1) / 2) * fontSize * 1.2); });
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false }));
            sprite.scale.set(width / 256, height / 256, 1);
            return { sprite, ctx, canvas, material: sprite.material };
        }

        function createCloseButton(width, height, posY) {
            const { sprite } = createTextSprite("X", 60, 128, 128, 'white', '#D32F2F');
            sprite.scale.set(0.5, 0.5, 1);
            sprite.position.set(width / 2 - 0.15, posY + height / 2 - 0.15, 0.0);
            sprite.userData = { isMenuBtn: true, action: 'resume_game' };
            sprite.visible = false;
            closeButtons.push(sprite);
            return sprite;
        }

        // --- Paineis Principais ---
        menuGroup.add(createMenuPanel(3.0, 3.4, -0.6));
        localMenuGroup.add(createMenuPanel(3.0, 3.5, 0.0));
        optionsGroup.add(createMenuPanel(3.0, 4.5, 0.0));
        aboutGroup.add(createMenuPanel(4.5, 4.2, 0.0));
        multiplayerGroup.add(createMenuPanel(3.5, 4.0, 0.0));

        menuGroup.add(createCloseButton(3.2, 4.2, -0.9));
        localMenuGroup.add(createCloseButton(3.0, 3.5, 0.0));
        optionsGroup.add(createCloseButton(3.0, 4.5, 0.0));
        aboutGroup.add(createCloseButton(4.5, 4.2, 0.0));
        multiplayerGroup.add(createCloseButton(3.5, 4.0, 0.0));

        // --- T√çTULO 3D (JUNGLE CHESS 3D) ---
        // Usando o novo logo animado do title.js
        const titleGroup = createJungleChessLogo(menuGroup, camera);
        // O logo √© muito grande, diminuir escala e colocar na posi√ß√£o certa
        titleGroup.scale.set(0.012, 0.012, 0.012);
        titleGroup.position.y = 2.2;

        // --- MENU PRINCIPAL ---
        const btnLocalMenu = createTextSprite(window.i18n('ui.play_local'), 50, 512, 128, '#000000', '#6B4226').sprite;
        btnLocalMenu.position.y = 0.6; btnLocalMenu.userData = { isMenuBtn: true, action: 'show_local_menu' }; menuGroup.add(btnLocalMenu);
        const btnMulti = createTextSprite(window.i18n('ui.play_multi'), 50, 512, 128, '#000000', '#615142').sprite;
        btnMulti.position.y = 0.0; btnMulti.userData = { isMenuBtn: true, action: 'show_multiplayer' }; menuGroup.add(btnMulti);
        const btnOptions = createTextSprite(window.i18n('ui.options'), 50, 512, 128, '#000000', '#6B4226').sprite;
        btnOptions.position.y = -0.6; btnOptions.userData = { isMenuBtn: true, action: 'show_options' }; menuGroup.add(btnOptions);
        const btnRestart = createTextSprite(window.i18n('ui.restart'), 50, 512, 128, '#000000', '#4F4237').sprite;
        btnRestart.position.y = -1.2; btnRestart.userData = { isMenuBtn: true, action: 'restart_game' }; btnRestart.visible = false; menuGroup.add(btnRestart);
        const btnAbout = createTextSprite(window.i18n('ui.about'), 50, 512, 128, '#000000', '#615142').sprite;
        btnAbout.position.y = -1.8; btnAbout.userData = { isMenuBtn: true, action: 'show_about' }; menuGroup.add(btnAbout);

        // --- SUBMENU: JOGO LOCAL ---
        const localTitle = createTextSprite(window.i18n('ui.play_local'), 80, 512, 128, '#ffeb3b').sprite;
        localTitle.position.y = 1.0; localMenuGroup.add(localTitle);
        const btnSingle = createTextSprite(window.i18n('ui.pvp_local'), 50, 512, 128, '#000000', '#6B4226').sprite;
        btnSingle.position.y = 0.0; btnSingle.userData = { isMenuBtn: true, action: 'start_game_pvp' }; localMenuGroup.add(btnSingle);
        const btnCPU = createTextSprite(window.i18n('ui.vs_cpu'), 50, 512, 128, '#000000', '#615142').sprite;
        btnCPU.position.y = -1.0; btnCPU.userData = { isMenuBtn: true, action: 'start_game_cpu' }; localMenuGroup.add(btnCPU);

        // --- SUBMENU: MULTIPLAYER (P2P DApp) ---
        const multiTitle = createTextSprite(window.i18n('ui.play_multi'), 80, 512, 128, '#ffeb3b').sprite;
        multiTitle.position.y = 1.0; multiplayerGroup.add(multiTitle);
        const btnInvite = createTextSprite(window.i18n('ui.generate_link'), 50, 512, 128, '#000000', '#6B4226').sprite;
        btnInvite.position.y = 0.0; btnInvite.userData = { isMenuBtn: true, action: 'generate_link' }; multiplayerGroup.add(btnInvite);
        const multiStatusText = createTextSprite(window.i18n('ui.share_url'), 30, 512, 128, 'white').sprite;
        multiStatusText.position.y = -0.8; multiplayerGroup.add(multiStatusText);
        const btnMultiBack = createTextSprite(window.i18n('ui.back'), 50, 512, 128, '#000000', '#4F4237').sprite;
        btnMultiBack.position.y = -1.5; btnMultiBack.userData = { isMenuBtn: true, action: 'show_menu' }; multiplayerGroup.add(btnMultiBack);

        // --- SUBMENU: OP√á√ïES ---
        const optTitle = createTextSprite(window.i18n('ui.options'), 80, 512, 128, '#ffeb3b').sprite;
        optTitle.position.y = 1.6; optionsGroup.add(optTitle);
        const btnTipsObj = createTextSprite(window.i18n('ui.tips_on'), 50, 512, 128, '#000000', '#6B4226');
        const btnTips = btnTipsObj.sprite;
        btnTips.position.y = 0.8; btnTips.userData = { isMenuBtn: true, action: 'toggle_tips' }; optionsGroup.add(btnTips);
        const btnVR = createTextSprite(window.i18n('ui.enter_vr'), 50, 512, 128, '#000000', '#615142').sprite;
        btnVR.position.y = 0.0; btnVR.userData = { isMenuBtn: true, action: 'show_vr' }; optionsGroup.add(btnVR);
        const btnAR = createTextSprite(window.i18n('ui.enter_ar'), 50, 512, 128, '#000000', '#6B4226').sprite;
        btnAR.position.y = -0.8; btnAR.userData = { isMenuBtn: true, action: 'show_ar' }; optionsGroup.add(btnAR);
        const btnOptBack = createTextSprite(window.i18n('ui.back'), 50, 512, 128, '#000000', '#4F4237').sprite;
        btnOptBack.position.y = -1.6; btnOptBack.userData = { isMenuBtn: true, action: 'show_menu' }; optionsGroup.add(btnOptBack);


        // --- SUBMENU: SOBRE ---
        const abtTitle = createTextSprite(window.i18n('ui.about'), 80, 512, 128, '#ffeb3b').sprite;
        abtTitle.position.y = 1.5; aboutGroup.add(abtTitle);
        const abtText = createTextSprite(window.i18n('ui.about_text'), 40, 1024, 640, 'white').sprite;
        abtText.position.y = 0.0; aboutGroup.add(abtText);
        const btnAbtBack = createTextSprite(window.i18n('ui.back'), 50, 512, 128, '#000000', '#4F4237').sprite;
        btnAbtBack.position.y = -1.5; btnAbtBack.userData = { isMenuBtn: true, action: 'show_menu' }; aboutGroup.add(btnAbtBack);

        function switchScene(newScene) {
            currentScene = newScene;
            const targetGameY = currentScene === 'game' ? 0 : -3.5;

            document.getElementById('ui-container').style.display = currentScene === 'game' ? 'flex' : 'none';
            document.getElementById('status').style.display = currentScene === 'game' ? 'block' : 'none';
            hudGroup.visible = currentScene === 'game';

            menuGroup.visible = currentScene === 'menu';
            localMenuGroup.visible = currentScene === 'local_menu';
            optionsGroup.visible = currentScene === 'options';
            aboutGroup.visible = currentScene === 'about';
            multiplayerGroup.visible = currentScene === 'multiplayer';

            if (!renderer.xr.isPresenting) {
                gameGroup.userData.targetY = targetGameY;
            }

            const targetControlsY = currentScene === 'game' ? 0 : 0.8;
            if (controls.userData) { controls.userData.target.set(0, targetControlsY, 0); }

            if (currentScene === 'game') {
                camera.userData.targetPos.set(0, 7, 8);
            } else {
                camera.userData.targetPos.set(0, 7, 8);
            }
            isTransitioningCamera = true;

            // Re-eval avaliar a visibilidade da m√£o caso a cena mude
            if (window.setDominantHand) {
                if (dominantController) {
                    const dom = dominantController;
                    dominantController = null; // force update
                    window.setDominantHand(dom);
                } else if (currentScene === 'game') {
                    // Force a default hand to hold the phone if none selected yet
                    window.setDominantHand(controller1);
                }
            }
        }

        // ==========================================/
        // P2P DAPP MULTIPLAYER LOGIC (PeerJS)
        // ==========================================/
        function updateStatusText(text) {
            multiStatusText.material.map = createTextSprite(text, 30, 512, 128, 'white').material.map;
        }

        function fallbackCopyTextToClipboard(text) {
            var textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.top = "0"; textArea.style.left = "0"; textArea.style.position = "fixed";
            document.body.appendChild(textArea); textArea.focus(); textArea.select();
            try { document.execCommand('copy'); } catch (err) { console.error('Falha ao copiar', err); }
            document.body.removeChild(textArea);
        }

        function setupP2PConnection() {
            peerConnection.on('open', () => {
                gameMode = 'multi';
                myTeamId = isHost ? 1 : 0;
                btnRestart.visible = false;
                updateGameTitle(window.i18n('ui.net_p2_joined'));

                hasGameStarted = true;
                closeButtons.forEach(b => b.visible = true);

                gameGroup.rotation.y = isHost ? 0 : Math.PI;

                switchScene('game');
                restarting = true;
            });
            peerConnection.on('data', (data) => {
                if (data.type === 'move') {
                    executeRemoteMove(data.startX, data.startY, data.endX, data.endY);
                }
            });
        }

        function initP2PHost() {
            if (peer) return;
            const roomCode = Math.random().toString(36).substring(2, 8);

            const link = window.location.href.split('?')[0] + '?room=' + roomCode;

            fallbackCopyTextToClipboard(link);
            btnInvite.material.map = createTextSprite(window.i18n('ui.net_link_copied'), 50, 512, 128, '#000000', '#ffeb3b').material.map;
            updateStatusText(window.i18n('ui.net_starting'));

            if (navigator.share) {
                navigator.share({
                    title: 'Jungle Chess 3D',
                    text: 'Vem jogar Jungle Chess comigo! Clica no link para entrar na minha mesa:',
                    url: link
                }).catch((error) => console.log('Erro ao compartilhar:', error));
            }

            peer = new Peer(roomCode);
            peer.on('open', (id) => {
                updateStatusText(window.i18n('ui.net_waiting'));
                updateGameTitle(window.i18n('ui.net_room_open'));
                hasGameStarted = true;
                closeButtons.forEach(b => b.visible = true);
            });
            peer.on('connection', (conn) => {
                peerConnection = conn;
                setupP2PConnection();
            });
        }

        function initP2PGuest(roomId) {
            peer = new Peer();
            peer.on('open', () => {
                updateStatusText(window.i18n('ui.net_connecting'));
                peerConnection = peer.connect(roomId);
                setupP2PConnection();
            });
        }

        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const joinRoom = urlParams.get('room');
            if (joinRoom) {
                isHost = false;
                switchScene('multiplayer');
                btnInvite.visible = false;
                initP2PGuest(joinRoom);
            }
        });

        // ==========================================/
        // ALGORITMO DA INTELIG√äNCIA ARTIFICIAL (CPU)
        // ==========================================/
        function makeCPUMove() {
            if (currentScene !== 'game' || gameMode !== 'cpu' || engine.currentTurn !== 0 || engine.winner !== null) {
                isCPUThinking = false;
                return;
            }

            const cpuPieces = pieceMeshes.filter(p => p.team === 0 && !p.isDead && !p.isDying);
            let possibleMoves = [];

            cpuPieces.forEach(piece => {
                for (let x = 0; x < BOARD_COLS; x++) {
                    for (let y = 0; y < BOARD_ROWS; y++) {
                        if (engine.isValidMove(piece, piece.gridX, piece.gridY, x, y)) {
                            let score = 0;
                            const target = engine.getPieceAt(x, y);

                            if (target) {
                                score += target.rank * 10;
                                if (piece.rank === 1 && target.rank === 8) score += 100;
                            }

                            if (engine.isDen(x, y, 1)) {
                                score += 10000;
                            }

                            if (engine.isTrap(x, y, 1)) {
                                score -= 50;
                            }

                            const oldDistToDen = Math.abs(piece.gridX - 3) + Math.abs(piece.gridY - 8);
                            const newDistToDen = Math.abs(x - 3) + Math.abs(y - 8);
                            if (newDistToDen < oldDistToDen) {
                                score += 2;
                            }

                            possibleMoves.push({ piece, x, y, score });
                        }
                    }
                }
            });

            if (possibleMoves.length > 0) {
                possibleMoves.sort((a, b) => b.score - a.score);
                const bestScore = possibleMoves[0].score;
                const bestMoves = possibleMoves.filter(m => m.score === bestScore);
                const chosenMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];

                selectedPiece = chosenMove.piece;
                tryMove(chosenMove.x, chosenMove.y);
            } else {
                engine.currentTurn = 1;
            }

            isCPUThinking = false;
        }

        // ==========================================/
        // HUD ANCORADO NA C√ÇMARA E BAL√ïES DE FOFOCA (IM STYLE)
        // ==========================================/
        const hudGroup = new THREE.Group();
        camera.add(hudGroup);

        function createSquareHUDButton(text, bgColor, textColor = '#000000') {
            const width = 256; const height = 256;
            const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = bgColor;
            if (ctx.roundRect) ctx.roundRect(10, 10, width - 20, height - 20, 40); else ctx.fillRect(10, 10, width - 20, height - 20);
            ctx.fill();
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#000000';
            ctx.stroke();

            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `bold 100px sans-serif`;
            ctx.fillText(text, width / 2, height / 2 + 5);

            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false }));
            sprite.scale.set(0.3, 0.3, 1);
            sprite.userData = { isHUDButton: true, action: text };
            hudGroup.add(sprite);
            return sprite;
        }

        const menuHudBtn = createSquareHUDButton('‚ò∞', '#6B4226', '#000000');

        function updateHUDPosition() {
            const dist = -2.5;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * Math.abs(dist);
            const width = height * camera.aspect;
            const rightEdge = (width / 2) - 0.25;
            const topEdge = (height / 2) - 0.25;
            menuHudBtn.position.set(rightEdge, topEdge, dist);
        }
        updateHUDPosition();

        let activeDialogues = [];

        function createSpeechBubbleTexture(text, pieceData, isOffsetLeft, replyTo = null) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            const team = pieceData.team;
            const rank = pieceData.rank;
            const bgColor = team === 0 ? '#e1bee7' : '#c8e6c9';
            const tagColor = team === 0 ? '#ce93d8' : '#a5d6a7';
            const strokeColor = '#000000';
            const teamColor = TEAMS[team].color;

            const emoji = RANKS[rank].icon;
            const nickname = getPieceNickname(pieceData);

            ctx.lineWidth = 6;
            ctx.strokeStyle = strokeColor;
            ctx.lineJoin = 'round';

            ctx.font = 'bold 45px "Courier New", Courier, monospace';
            const words = text.split(' ');
            let line = ''; let lines = [];
            const maxW = 650;
            for (let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                let metrics = ctx.measureText(testLine);
                if (metrics.width > maxW && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            const bubbleW = 760;
            const replyHeightAdd = replyTo ? 100 : 0;
            const contentH = lines.length * 50;
            const bubbleH = Math.max(120, contentH + 60) + replyHeightAdd;
            const bubbleY = 350;
            const bubbleX = isOffsetLeft ? 50 : (1024 - bubbleW - 50);
            const c = 25;

            ctx.font = 'bold 32px "Courier New", Courier, monospace';
            const tagText = nickname;
            const tagW = 100 + ctx.measureText(tagText).width;
            const tagH = 64;
            const tagX = isOffsetLeft ? bubbleX + 20 : bubbleX + bubbleW - tagW - 20;
            const tagY = bubbleY - tagH;

            ctx.fillStyle = tagColor;
            ctx.beginPath();
            ctx.moveTo(tagX + 15, tagY);
            ctx.lineTo(tagX + tagW - 15, tagY);
            ctx.lineTo(tagX + tagW, tagY + tagH);
            ctx.lineTo(tagX, tagY + tagH);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.shadowColor = 'rgba(0,0,0,0.4)';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 6;
            ctx.shadowOffsetY = 6;

            const tailTargetX = 512;
            const tailTargetY = 1000;
            const tailBaseX = bubbleX + (isOffsetLeft ? bubbleW - 120 : 120);

            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.moveTo(bubbleX + c, bubbleY);
            ctx.lineTo(bubbleX + bubbleW - c, bubbleY);
            ctx.lineTo(bubbleX + bubbleW, bubbleY + c);
            ctx.lineTo(bubbleX + bubbleW, bubbleY + bubbleH - c);
            ctx.lineTo(bubbleX + bubbleW - c, bubbleY + bubbleH);

            ctx.lineTo(tailBaseX + 25, bubbleY + bubbleH);
            ctx.lineTo(tailTargetX, tailTargetY);
            ctx.lineTo(tailBaseX - 25, bubbleY + bubbleH);

            ctx.lineTo(bubbleX + c, bubbleY + bubbleH);
            ctx.lineTo(bubbleX, bubbleY + bubbleH - c);
            ctx.lineTo(bubbleX, bubbleY + c);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.shadowColor = 'transparent';

            const avatarRadius = 22;
            const avatarX = tagX + 35;
            const avatarY = tagY + tagH / 2;

            ctx.beginPath();
            ctx.arc(avatarX, avatarY, avatarRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = teamColor;
            ctx.stroke();

            ctx.font = '28px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, avatarX, avatarY + 2);

            ctx.fillStyle = strokeColor;
            ctx.font = 'bold 30px "Courier New", Courier, monospace';
            ctx.textAlign = 'left';
            ctx.fillText(nickname, avatarX + avatarRadius + 12, avatarY + 2);

            let startY = bubbleY + 40;
            if (replyTo) {
                const rx = bubbleX + 30;
                const ry = bubbleY + 25;
                const rw = bubbleW - 60;
                const rh = 80;

                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.moveTo(rx + 8, ry);
                ctx.lineTo(rx + rw - 8, ry);
                ctx.quadraticCurveTo(rx + rw, ry, rx + rw, ry + 8);
                ctx.lineTo(rx + rw, ry + rh - 8);
                ctx.quadraticCurveTo(rx + rw, ry + rh, rx + rw - 8, ry + rh);
                ctx.lineTo(rx + 8, ry + rh);
                ctx.quadraticCurveTo(rx, ry + rh, rx, ry + rh - 8);
                ctx.lineTo(rx, ry + 8);
                ctx.quadraticCurveTo(rx, ry, rx + 8, ry);
                ctx.fill();

                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.moveTo(rx, ry + 8);
                ctx.lineTo(rx + 6, ry + 8);
                ctx.lineTo(rx + 6, ry + rh - 8);
                ctx.lineTo(rx, ry + rh - 8);
                ctx.fill();

                ctx.fillStyle = '#222222';
                ctx.font = 'bold 22px "Courier New", Courier, monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Replying to @${replyTo.nickname}`, rx + 15, ry + 12);

                ctx.fillStyle = '#444444';
                ctx.font = 'italic 26px "Courier New", Courier, monospace';
                let snippetArray = Array.from(replyTo.text);
                let snippet = snippetArray.length > 25 ? snippetArray.slice(0, 25).join('') + '...' : replyTo.text;
                ctx.fillText(`"${snippet}"`, rx + 15, ry + 40);

                startY += 90;
            }

            ctx.font = 'bold 45px "Courier New", Courier, monospace';
            ctx.fillStyle = strokeColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const remainingH = bubbleH - (startY - bubbleY);
            startY = startY + (remainingH / 2) - ((lines.length - 1) * 25);

            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i].trim(), bubbleX + bubbleW / 2, startY + (i * 50));
            }

            return new THREE.CanvasTexture(canvas);
        }

        function spawnSpeechBubble(pieceData, text, replyTo = null) {
            const isOffsetLeft = Math.random() > 0.5;
            const tex = createSpeechBubbleTexture(text, pieceData, isOffsetLeft, replyTo);
            const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, transparent: true });
            const sprite = new THREE.Sprite(mat);

            sprite.center.set(0.5, 0.0);
            sprite.scale.set(4.5, 4.5, 1);
            sprite.position.set(0, 0.3, 0);

            pieceData.mesh.add(sprite);
            activeDialogues.push({ sprite, life: 5.5, piece: pieceData, timer: 0 });

            logChat(pieceData, text, replyTo);
        }


        // ==========================================/
        // TABULEIRO E MATERIAIS
        // ==========================================/
        function createWaterTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4682B4'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#63b4f5'; ctx.lineWidth = 3;
            for (let y = -20; y < 300; y += 15) {
                ctx.beginPath();
                for (let x = 0; x <= 256; x += 15) ctx.lineTo(x, y + Math.sin(x * 0.1) * 6);
                ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        function createGrassTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#6B8E23'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#557519'; ctx.lineWidth = 3; ctx.lineCap = ctx.lineJoin = 'round';
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 256, y = Math.random() * 256, size = 6 + Math.random() * 8;
                ctx.beginPath(); ctx.moveTo(x - size, y + size); ctx.lineTo(x, y); ctx.lineTo(x + size, y + size); ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        function createDenTexture(bgColor) {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 256, 256); ctx.lineCap = 'round';
            for (let i = 0; i < 100; i++) {
                ctx.strokeStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.6)' : 'rgba(100,60,30,0.8)';
                ctx.lineWidth = 2 + Math.random() * 3;
                const x1 = Math.random() * 256, y1 = Math.random() * 256;
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x1 + (Math.random() - 0.5) * 80, y1 + (Math.random() - 0.5) * 80); ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        const matLand = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createGrassTexture(), roughness: 0.9 });
        const matWater = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createWaterTexture(), roughness: 0.1, transparent: true, opacity: 0.85, flatShading: true });
        const matTrap = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createDenTexture('#DAA520'), roughness: 1.0 });
        const matDenRed = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createDenTexture('#8B0000'), roughness: 1.0 });
        const matDenGreen = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createDenTexture('#006400'), roughness: 1.0 });

        const tileSize = 1; const tileSpacing = 0.05; const tileMeshes = [];

        function getWorldPos(gridX, gridY) { return new THREE.Vector3((gridX - BOARD_COLS / 2 + 0.5) * tileSize, 0, (gridY - BOARD_ROWS / 2 + 0.5) * tileSize); }

        const craterGeo = new THREE.TorusGeometry(0.28, 0.06, 4, 16);
        const trapTextGeo = new THREE.PlaneGeometry(0.7, 0.7);
        const trapObjMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });

        function createTrapTextTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FF0000'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 5; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 32px sans-serif';
            ctx.strokeText('TRAP', 64, 64); ctx.fillText('TRAP', 64, 64);
            const tex = new THREE.CanvasTexture(canvas); tex.center.set(0.5, 0.5); return tex;
        }
        const trapTextMat = new THREE.MeshBasicMaterial({ map: createTrapTextTexture(), transparent: true, opacity: 0.2, depthWrite: false });

        const tileGeo = new THREE.BoxGeometry(tileSize - tileSpacing, 0.2, tileSize - tileSpacing);
        const waterGeoBase = new THREE.BoxGeometry(tileSize - tileSpacing, 0.2, tileSize - tileSpacing, 5, 1, 5);

        for (let x = 0; x < BOARD_COLS; x++) {
            for (let y = 0; y < BOARD_ROWS; y++) {
                let mat = matLand; let geo = tileGeo;
                const isWater = engine.isWater(x, y), isTrap = engine.isTrap(x, y, 0) || engine.isTrap(x, y, 1);
                if (isWater) { mat = matWater; geo = waterGeoBase.clone(); }
                else if (isTrap) mat = matTrap; else if (engine.isDen(x, y, 0)) mat = matDenRed; else if (engine.isDen(x, y, 1)) mat = matDenGreen;

                const tile = new THREE.Mesh(geo, mat); const pos = getWorldPos(x, y); tile.position.copy(pos);
                if (isWater) tile.position.y -= 0.04; tile.receiveShadow = true;
                tile.userData = { isTile: true, gridX: x, gridY: y, isWater: isWater };

                if (isWater) {
                    tile.userData.originalVertices = []; const posAttr = geo.attributes.position;
                    for (let i = 0; i < posAttr.count; i++) tile.userData.originalVertices.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
                }
                gameGroup.add(tile); tileMeshes.push(tile);

                if (isTrap) {
                    const crater = new THREE.Mesh(craterGeo, trapObjMat);
                    crater.rotation.x = Math.PI / 2; crater.scale.z = 0.5; crater.position.set(pos.x, 0.12, pos.z);
                    gameGroup.add(crater);
                    const textPlane = new THREE.Mesh(trapTextGeo, trapTextMat);
                    textPlane.rotation.x = -Math.PI / 2; textPlane.position.set(pos.x, 0.11, pos.z);
                    gameGroup.add(textPlane);
                }
            }
        }
        const borderGeo = new THREE.BoxGeometry(BOARD_COLS + 0.2, 0.5, BOARD_ROWS + 0.2);
        const borderMat = new THREE.MeshStandardMaterial({ color: 0x3d2314 });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.y = -0.35; border.receiveShadow = true; gameGroup.add(border);

        // ==========================================/
        // EASTER EGG: Secret Glass Tiles
        // ==========================================/
        const secretTileGeo = new THREE.BoxGeometry(tileSize - tileSpacing, 0.2, tileSize - tileSpacing);
        const secretTileMat = new THREE.MeshStandardMaterial({ color: 0x88ffff, transparent: true, opacity: 0.3, roughness: 0.1, metalness: 0.8 });

        const secretTileLeft = new THREE.Mesh(secretTileGeo, secretTileMat);
        const posLeft = getWorldPos(-1, 4); secretTileLeft.position.copy(posLeft);
        secretTileLeft.visible = false; secretTileLeft.userData = { isTile: true, gridX: -1, gridY: 4 };
        gameGroup.add(secretTileLeft); tileMeshes.push(secretTileLeft);

        const secretTileRight = new THREE.Mesh(secretTileGeo, secretTileMat);
        const posRight = getWorldPos(7, 4); secretTileRight.position.copy(posRight);
        secretTileRight.visible = false; secretTileRight.userData = { isTile: true, gridX: 7, gridY: 4 };
        gameGroup.add(secretTileRight); tileMeshes.push(secretTileRight);

        // ==========================================/
        // CILINDRO ARREDONDADO E MATERIAL "MASSINHA"
        // ==========================================/
        function createPieceMaterial(rank, team) {
            const data = RANKS[rank], tData = TEAMS[team];
            const cTop = document.createElement('canvas'); cTop.width = cTop.height = 256; const ctxTop = cTop.getContext('2d');
            ctxTop.fillStyle = tData.color; ctxTop.fillRect(0, 0, 256, 256);
            ctxTop.fillStyle = '#fff'; ctxTop.textAlign = 'center'; ctxTop.textBaseline = 'middle'; ctxTop.font = 'bold 160px sans-serif';
            ctxTop.fillText(rank.toString(), 128, 140); ctxTop.strokeStyle = '#000'; ctxTop.lineWidth = 4; ctxTop.strokeText(rank.toString(), 128, 140);
            const cSide = document.createElement('canvas'); cSide.width = 1024; cSide.height = 280; const ctxSide = cSide.getContext('2d');
            ctxSide.fillStyle = tData.color; ctxSide.fillRect(0, 0, 1024, 280);
            ctxSide.fillStyle = '#fff'; ctxSide.textAlign = 'center'; ctxSide.textBaseline = 'middle'; ctxSide.font = 'bold 100px sans-serif';
            ctxSide.fillText(`${data.icon} ${data.name.toUpperCase()} ${data.icon}`, 512, 140);
            const texTop = new THREE.CanvasTexture(cTop); texTop.center.set(0.5, 0.5);
            const texSide = new THREE.CanvasTexture(cSide);
            const matConfig = { roughness: 0.6, metalness: 0.1, clearcoat: 0.3, clearcoatRoughness: 0.8 };
            return [
                new THREE.MeshPhysicalMaterial({ map: texSide, ...matConfig }),
                new THREE.MeshPhysicalMaterial({ map: texTop, ...matConfig }),
                new THREE.MeshPhysicalMaterial({ color: tData.color, ...matConfig })
            ];
        }

        function createEmojiSprite(rank) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '280px sans-serif';
            ctx.shadowColor = 'rgba(255, 255, 100, 1.0)'; ctx.shadowBlur = 60;
            ctx.fillText(RANKS[rank].icon, 256, 280);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            sprite.scale.set(1.5, 1.5, 1); sprite.position.y = 0.4;
            return sprite;
        }

        let activeParticles = [];
        function spawnCustomParticles(emojis, pos, count = 20) {
            for (let i = 0; i < count; i++) {
                const emoji = emojis[Math.floor(Math.random() * emojis.length)];
                const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d'); ctx.font = '60px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(emoji, 64, 64);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 1 }));
                sprite.position.copy(pos); sprite.position.y = 1.0;
                const angle = Math.random() * Math.PI * 2, speed = 1 + Math.random() * 3, velY = 3 + Math.random() * 5;
                gameGroup.add(sprite);
                activeParticles.push({ mesh: sprite, vx: Math.cos(angle) * speed, vy: velY, vz: Math.sin(angle) * speed, life: 1.0 });
            }
        }

        function spawnVictoryParticles(rank, pos) { spawnCustomParticles(PARTICLE_EMOJIS[rank], pos, 40); }

        function updatePieceTopNumber(pd, text) {
            const material = pd.cylinder.material[1];
            const canvas = material.map.image; const ctx = canvas.getContext('2d');
            ctx.fillStyle = TEAMS[pd.team].color; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 160px sans-serif';
            ctx.fillText(text, 128, 140); ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeText(text, 128, 140);
            material.map.needsUpdate = true;
        }

        function createRoundedCylinder(radius, height, radialSegments, filletRadius, filletSegments) {
            const points = []; points.push(new THREE.Vector2(0, -height / 2));
            for (let i = 0; i <= filletSegments; i++) { const a = (i / filletSegments) * (Math.PI / 2); points.push(new THREE.Vector2(radius - filletRadius + Math.sin(a) * filletRadius, -height / 2 + filletRadius - Math.cos(a) * filletRadius)); }
            for (let i = 0; i <= filletSegments; i++) { const a = (i / filletSegments) * (Math.PI / 2); points.push(new THREE.Vector2(radius - filletRadius + Math.cos(a) * filletRadius, height / 2 - filletRadius + Math.sin(a) * filletRadius)); }
            points.push(new THREE.Vector2(0, height / 2));
            const geo = new THREE.LatheGeometry(points, radialSegments);
            geo.rotateY(-Math.PI / 2); geo.computeVertexNormals();
            const pos = geo.attributes.position, uv = geo.attributes.uv;
            for (let i = 0; i < uv.count; i++) {
                const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
                if (y > height / 2 - 0.001) uv.setXY(i, 0.5 + x / (radius * 2), 0.5 - z / (radius * 2));
                else if (y < -height / 2 + 0.001) uv.setXY(i, 0.5 + x / (radius * 2), 0.5 + z / (radius * 2));
                else { let v = (y - (-height / 2 + filletRadius)) / (height - 2 * filletRadius); uv.setY(i, Math.max(0, Math.min(1, v))); }
            }
            geo.clearGroups(); let currentMat = -1, groupStart = 0, groupCount = 0; const index = geo.index;
            for (let i = 0; i < index.count; i += 3) {
                const a = index.getX(i), b = index.getX(i + 1), c = index.getX(i + 2), avgY = (pos.getY(a) + pos.getY(b) + pos.getY(c)) / 3;
                let matIdx = 0; if (avgY > height / 2 - 0.001) matIdx = 1; else if (avgY < -height / 2 + 0.001) matIdx = 2;
                if (matIdx !== currentMat) { if (currentMat !== -1) geo.addGroup(groupStart, groupCount, currentMat); currentMat = matIdx; groupStart = i; groupCount = 3; } else groupCount += 3;
            }
            if (groupCount > 0) geo.addGroup(groupStart, groupCount, currentMat);
            return geo;
        }

        const pieceGeo = createRoundedCylinder(0.35, 0.6, 32, 0.08, 6);
        const hitBoxGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.6);
        const hitBoxMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false });

        let pieceMeshes = [];

        function initPieces() {
            pieceMeshes.forEach(p => gameGroup.remove(p.mesh)); pieceMeshes = [];
            activeParticles.forEach(p => gameGroup.remove(p.mesh)); activeParticles = [];
            engine.reset();

            INITIAL_SETUP.forEach(setup => {
                const pos = getWorldPos(setup.x, setup.y);
                const group = new THREE.Group();
                group.position.set(pos.x, 0.4, pos.z);
                const mats = createPieceMaterial(setup.r, setup.t);
                const cylinder = new THREE.Mesh(pieceGeo, mats);
                cylinder.castShadow = true; cylinder.receiveShadow = true; cylinder.rotation.y = setup.t === 0 ? 0 : Math.PI;
                group.add(cylinder);
                const sprite = createEmojiSprite(setup.r); sprite.visible = false; group.add(sprite);
                const hitBox = new THREE.Mesh(hitBoxGeo, hitBoxMat);
                const pieceData = {
                    gridX: setup.x, gridY: setup.y, team: setup.t, rank: setup.r,
                    mesh: group, cylinder: cylinder, sprite: sprite, startPos: group.position.clone(), targetPos: group.position.clone(),
                    isMoving: false, moveProgress: 0, squashTimer: 0, capturedPiece: null, isVictoryPending: false,
                    isDying: false, isDead: false, isMorphing: false, morphTimer: 0, isBigAnim: false, captureAnimTimer: 0,
                    trapAnimState: 0, trapNumberVisual: setup.r, trapTimer: 0, isInDanger: false,
                    baseTeamColor: new THREE.Color(TEAMS[setup.t].color)
                };
                hitBox.userData = { isPiece: true, pieceData: pieceData };
                group.add(hitBox);
                gameGroup.add(group); pieceMeshes.push(pieceData); engine.addPiece(pieceData);
            });
        }
        initPieces();

        const highlightGeo = new THREE.RingGeometry(0.3, 0.4, 32); highlightGeo.rotateX(-Math.PI / 2);
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat); highlightMesh.position.y = 0.15; highlightMesh.visible = false;
        gameGroup.add(highlightMesh);

        let selectedPiece = null;
        const validHighlightMeshes = [];

        function showValidMoves(piece) {
            clearHighlights();
            const playerColor = TEAMS[piece.team].color;
            for (let x = 0; x < BOARD_COLS; x++) {
                for (let y = 0; y < BOARD_ROWS; y++) {
                    if (engine.isValidMove(piece, piece.gridX, piece.gridY, x, y)) {

                        let isThreatened = false;
                        let threatEmoji = "";

                        if (tipsEnabled && gameMode === 'cpu' && piece.team === engine.currentTurn) {
                            const originalX = piece.gridX;
                            const originalY = piece.gridY;
                            const targetPiece = engine.getPieceAt(x, y);

                            engine.board[originalX][originalY] = null;
                            engine.board[x][y] = piece;
                            piece.gridX = x; piece.gridY = y;

                            for (let enemy of pieceMeshes) {
                                if (enemy.team !== piece.team && !enemy.isDead && enemy.pieceData !== targetPiece) {
                                    if (engine.isValidMove(enemy, enemy.gridX, enemy.gridY, x, y)) {
                                        isThreatened = true;
                                        threatEmoji = RANKS[enemy.rank].icon;
                                        break;
                                    }
                                }
                            }

                            piece.gridX = originalX; piece.gridY = originalY;
                            engine.board[originalX][originalY] = piece;
                            engine.board[x][y] = targetPiece;
                        }

                        let hlColor = isThreatened ? '#D32F2F' : playerColor;

                        const hl = new THREE.Mesh(highlightGeo, new THREE.MeshBasicMaterial({ color: hlColor, transparent: true, opacity: 0.7 }));
                        const pos = getWorldPos(x, y); hl.position.set(pos.x, 0.15, pos.z);
                        hl.userData = { isTile: true, gridX: x, gridY: y };

                        if (isThreatened) {
                            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
                            const ctx = canvas.getContext('2d'); ctx.font = '70px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(threatEmoji, 64, 64);
                            const planeGeo = new THREE.PlaneGeometry(0.5, 0.5);
                            const planeMat = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, depthWrite: false });
                            const emojiMesh = new THREE.Mesh(planeGeo, planeMat);
                            emojiMesh.rotation.x = -Math.PI / 2;
                            emojiMesh.position.y = 0.02;
                            hl.add(emojiMesh);
                        }

                        gameGroup.add(hl); validHighlightMeshes.push(hl);
                    }
                }
            }
        }

        function clearHighlights() { highlightMesh.visible = false; validHighlightMeshes.forEach(h => gameGroup.remove(h)); validHighlightMeshes.length = 0; }

        function handleMenuInteraction(obj) {
            playSound('beep-up');
            obj.scale.y *= 0.7; setTimeout(() => obj.scale.y /= 0.7, 150);
            const action = obj.userData.action;

            if (action === 'show_local_menu') { switchScene('local_menu'); }
            else if (action === 'start_game_pvp') {
                gameMode = 'pvp';
                gameGroup.rotation.y = 0;
                updateGameTitle("Local PVP");
                btnRestart.visible = true;

                hasGameStarted = true;
                closeButtons.forEach(b => b.visible = true);

                switchScene('game');
                restarting = true;
            }
            else if (action === 'start_game_cpu') {
                gameMode = 'cpu';
                gameGroup.rotation.y = 0;
                updateGameTitle("Local V.S. CPU");
                btnRestart.visible = true;

                hasGameStarted = true;
                closeButtons.forEach(b => b.visible = true);

                switchScene('game');
                restarting = true;
            }
            else if (action === 'restart_game') {
                switchScene('game');
                if (selectedPiece) { selectedPiece.targetPos.y = 0.4; selectedPiece = null; }
                clearHighlights(); restarting = true;
            }
            else if (action === 'resume_game') {
                if (hasGameStarted) switchScene('game');
            }
            else if (action === 'show_options') { switchScene('options'); }
            else if (action === 'show_about') { switchScene('about'); }
            else if (action === 'show_menu') { switchScene('menu'); }
            else if (action === 'show_multiplayer') { switchScene('multiplayer'); }
            else if (action === 'generate_link') {
                initP2PHost();
            }
            else if (action === 'toggle_tips') {
                tipsEnabled = !tipsEnabled;
                const newText = tipsEnabled ? "Dicas e Ajuda: ON" : "Dicas e Ajuda: OFF";
                const bgColor = tipsEnabled ? "#6B4226" : "#4F4237";
                const { canvas, ctx } = btnTipsObj;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = bgColor;
                if (ctx.roundRect) ctx.roundRect(10, 10, canvas.width - 20, height - 20, 30); else ctx.fillRect(10, 10, canvas.width - 20, canvas.height - 20);
                ctx.fill(); ctx.lineWidth = 6; ctx.strokeStyle = '#000000'; ctx.stroke();
                ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = 'bold 50px sans-serif'; ctx.fillText(newText, canvas.width / 2, canvas.height / 2);
                btnTipsObj.material.map.needsUpdate = true;
            } else if (action === 'show_vr') {
                vrButton.click();
            } else if (action === 'show_ar') {
                arButton.click();
            }
        }

        function handleInteraction(intersection) {
            const obj = intersection.object;
            if (obj.userData.isMenuBtn) { handleMenuInteraction(obj); return; }
            if (obj.userData.isHUDButton) {
                playSound('beep-up');
                obj.scale.set(0.25, 0.25, 1); setTimeout(() => obj.scale.set(0.3, 0.3, 1), 150);
                if (obj.userData.action === '‚ò∞') { switchScene('menu'); }
                return;
            }
            if (obj.userData.isVRScreen) {
                if (obj.userData.tab) {
                    const tabs = document.querySelectorAll('.phone-tab');
                    let targetBtn = tabs[0];
                    if (obj.userData.tab === 'tab-chat') targetBtn = tabs[1];
                    if (obj.userData.tab === 'tab-manual') targetBtn = tabs[2];
                    window.openPhoneTab(obj.userData.tab, targetBtn, true);
                    if (window.updateVRPhoneScreen) window.updateVRPhoneScreen();
                }
                return;
            }
            if (currentScene !== 'game' || engine.winner !== null || isCPUThinking) return;

            if ((gameMode === 'multi' || gameMode === 'cpu') && engine.currentTurn !== myTeamId) return;

            if (obj.userData.isPiece) {
                const pd = obj.userData.pieceData;
                if (!pd.isDead && !pd.isVictoryPending && !pd.isMoving && !pd.isBigAnim && pd.trapAnimState === 0) {
                    pd.isMorphing = true; pd.morphTimer = 1.0; playSound('morph');
                }
                if (pd.team === engine.currentTurn) {
                    if (selectedPiece && selectedPiece !== pd) selectedPiece.targetPos.y = 0.4;
                    selectedPiece = pd; selectedPiece.targetPos.y = 0.5;
                    highlightMesh.position.copy(getWorldPos(pd.gridX, pd.gridY));
                    highlightMesh.position.y = 0.15; highlightMesh.visible = true;
                    showValidMoves(pd);
                } else if (selectedPiece) { tryMove(pd.gridX, pd.gridY); }
            } else if (obj.userData.isTile && selectedPiece) { tryMove(obj.userData.gridX, obj.userData.gridY); }
        }

        function executeRemoteMove(startX, startY, endX, endY) {
            const piece = engine.getPieceAt(startX, startY);
            if (piece) {
                selectedPiece = piece;
                tryMove(endX, endY, true);
            }
        }

        function tryMove(endX, endY, isRemote = false) {
            if (engine.isValidMove(selectedPiece, selectedPiece.gridX, selectedPiece.gridY, endX, endY)) {
                const startX = selectedPiece.gridX;
                const startY = selectedPiece.gridY;

                if (gameMode === 'multi' && !isRemote && peerConnection && peerConnection.open) {
                    peerConnection.send({ type: 'move', startX, startY, endX, endY });
                }

                const isRat = selectedPiece.rank === 1;
                const captured = engine.executeMove(selectedPiece, endX, endY);
                const targetWorld = getWorldPos(endX, endY);

                // Easter egg visual activation
                if (engine.secretTileLeftActive && !secretTileLeft.visible) {
                    secretTileLeft.visible = true;
                    playSound('beep-up');
                }
                if (engine.secretTileRightActive && !secretTileRight.visible) {
                    secretTileRight.visible = true;
                    playSound('beep-up');
                }

                const startIsWater = engine.isWater(startX, startY);
                const endIsWater = engine.isWater(endX, endY);

                if (isRat && startIsWater !== endIsWater) { playSound('splash'); } else { playSound('jump'); }

                if (selectedPiece.trapAnimState > 0) selectedPiece.trapAnimState = 0;
                selectedPiece.startPos = selectedPiece.mesh.position.clone();
                selectedPiece.targetPos = new THREE.Vector3(targetWorld.x, 0.4, targetWorld.z);
                selectedPiece.isMoving = true; selectedPiece.moveProgress = 0;
                selectedPiece.isMorphing = false; selectedPiece.isBigAnim = false; selectedPiece.cylinder.visible = true;
                selectedPiece.capturedPiece = captured; selectedPiece.isVictoryPending = (engine.winner !== null);
                selectedPiece = null; clearHighlights();
            } else { if (selectedPiece) selectedPiece.targetPos.y = 0.4; selectedPiece = null; clearHighlights(); }
        }

        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        function onPointerDown(event) {
            initAudio();

            resetIdleTime();

            if (!gyroInitialized) {
                gyroInitialized = true;
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(response => {
                        if (response === 'granted') window.addEventListener('deviceorientation', handleOrientation);
                    }).catch(console.error);
                } else {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            }

            isTransitioningCamera = false;
            if (renderer.xr.isPresenting || event.target.tagName === 'BUTTON') return;
            if (event.touches && event.touches.length > 1) { return; }
            if (event.changedTouches) {
                mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
            } else {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            raycaster.setFromCamera(mouse, camera);
            let intersectables = [];
            if (currentScene === 'menu') intersectables = menuGroup.children;
            else if (currentScene === 'local_menu') intersectables = localMenuGroup.children;
            else if (currentScene === 'options') intersectables = optionsGroup.children;
            else if (currentScene === 'about') intersectables = aboutGroup.children;
            else if (currentScene === 'multiplayer') intersectables = multiplayerGroup.children;
            else if (currentScene === 'game') intersectables = [...gameGroup.children, ...hudGroup.children];

            const intersects = raycaster.intersectObjects(intersectables, true)
                .filter(hit => {
                    if (!hit.object.visible) return false;
                    const ud = hit.object.userData; if (!ud) return false;
                    if (currentScene === 'game') {
                        if (ud.isPiece && ud.pieceData === selectedPiece) return false;
                        return (ud.isPiece && ud.pieceData && !ud.pieceData.isDead) || ud.isTile || ud.isHUDButton;
                    }
                    else return ud.isMenuBtn;
                });
            if (intersects.length > 0) handleInteraction(intersects[0]);
            else if (selectedPiece && currentScene === 'game') { selectedPiece.targetPos.y = 0.4; selectedPiece = null; clearHighlights(); }
        }
        window.addEventListener('pointerdown', onPointerDown);

        let isPinching = false;
        let initialPinchDistance = 0;
        const initialGameScale = new THREE.Vector3();

        function onTouchStart(event) {
            isTransitioningCamera = false;
            resetIdleTime();
            if (renderer.xr.isPresenting && event.touches.length === 2) {
                event.preventDefault();
                const t1 = event.touches[0];
                const t2 = event.touches[1];
                initialPinchDistance = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
                initialGameScale.copy(gameGroup.scale);
                isPinching = true;
            }
        }

        function onTouchMove(event) {
            if (isPinching && event.touches.length === 2) {
                event.preventDefault();
                const t1 = event.touches[0];
                const t2 = event.touches[1];
                const currentPinchDistance = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
                const scaleFactor = currentPinchDistance / initialPinchDistance;
                const newScale = initialGameScale.clone().multiplyScalar(scaleFactor);
                newScale.clampScalar(0.1, 2.0);
                gameGroup.scale.copy(newScale);
            }
        }

        function onTouchEnd(event) {
            if (isPinching) {
                isPinching = false;
                gameGroup.userData.targetScale = gameGroup.scale.x;
            }
        }

        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchend', onTouchEnd);

        let hitTestSource = null, hitTestSourceRequested = false, reticle, isARPlaced = false, isARSession = false;
        reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        reticle.matrixAutoUpdate = false; reticle.visible = false; scene.add(reticle);

        // --- SISTEMA ROBUSTO E SEGURO DE COMANDOS VR ---
        const controllerModelFactory = new XRControllerModelFactory();

        function setupVRController(index) {
            const controller = renderer.xr.getController(index);
            const grip = renderer.xr.getControllerGrip(index);

            // Fallback: Bast√£o/Cilindro elegante (melhor que o cubo antigo)
            const fallbackGroup = new THREE.Group();
            const handleGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.12, 16);
            handleGeo.rotateX(Math.PI / 2); // Deitar o bast√£o para apontar para a frente
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const handleMesh = new THREE.Mesh(handleGeo, handleMat);
            fallbackGroup.add(handleMesh);
            grip.add(fallbackGroup);

            let factoryModel = null;

            // Escuta a conex√£o para ler o perfil do dispositivo de forma segura
            controller.addEventListener('connected', (event) => {
                const profiles = event.data.profiles || [];
                // Marcas conhecidas que costumam carregar bem no XRControllerModelFactory
                const isKnownSafe = profiles.some(p =>
                    p.includes('oculus') || p.includes('meta') ||
                    p.includes('valve') || p.includes('htc') || p.includes('windows')
                );

                if (isKnownSafe && !factoryModel) {
                    factoryModel = controllerModelFactory.createControllerModel(grip);

                    // Monkey Patch para capturar o infame erro do 'quaternion' no render loop
                    const origUpdate = factoryModel.updateMatrixWorld.bind(factoryModel);
                    factoryModel.updateMatrixWorld = function (force) {
                        try {
                            origUpdate(force);
                            fallbackGroup.visible = false; // Modelo oficial carregou e atualizou sem erro
                        } catch (e) {
                            // Se o modelo corromper, escondemos ele e ativamos o fallback instantaneamente
                            this.visible = false;
                            fallbackGroup.visible = true;
                        }
                    };

                    grip.add(factoryModel);
                }
            });

            scene.add(controller);
            scene.add(grip);

            // Linha de laser vis√≠vel saindo do comando
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffffff }));
            line.name = 'line'; line.scale.z = 5;
            controller.add(line);

            return { controller, grip };
        }

        const c0 = setupVRController(0);
        const controller1 = c0.controller;
        const grip1 = c0.grip;

        const c1 = setupVRController(1);
        const controller2 = c1.controller;
        const grip2 = c1.grip;

        // Oculta os fallback controllers quando o jogo inicia
        let controller1Fallback = grip1.children.find(c => c.type === 'Group');
        let controller2Fallback = grip2.children.find(c => c.type === 'Group');

        let controller1Selected = false, controller2Selected = false;
        let grip1Active = false, grip2Active = false;

        let isDoubleGripping = false;
        let isSingleGripping = false;
        let activeSingleController = null;
        let initialGripMatrix = new THREE.Matrix4();
        let initialGripM = new THREE.Vector3();
        let initialGripV = new THREE.Vector3();
        let initialGripDist = 0;
        let initialSinglePanPos = new THREE.Vector3();
        let initialGameGroupPos = new THREE.Vector3();

        // --- INICIO DO M√ìDULO DE PULSO (VR SMARTPHONE) ---
        function createLowPolyHandModel() {
            const container = new THREE.Group();

            const createBone = (radius, length, material) => {
                const group = new THREE.Group();
                const geo = new THREE.CylinderGeometry(radius * 0.8, radius, length, 6);
                const mesh = new THREE.Mesh(geo, material);
                mesh.position.y = length / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
                return { group, length };
            };

            const PIVOT_ANGLE = 0.099;
            const FINGER_OFFSETS = [-0.152, -0.12, -0.098, -0.348];

            const skinMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.5,
                flatShading: true,
                transparent: true,
                opacity: 0.6
            });
            const phoneMat = new THREE.MeshStandardMaterial({ color: 0x222428, roughness: 0.4, metalness: 0.6 });
            const screenMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // Increased brightness from 0x111111 to 0xffffff

            // --- SMARTPHONE ---
            const phonePivot = new THREE.Group();
            phonePivot.position.set(-0.4, 0, 0);
            const phoneGroup = new THREE.Group();
            phoneGroup.position.set(0.4, 0, 0);

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.6, 0.08), phoneMat);
            body.castShadow = body.receiveShadow = true;
            phoneGroup.add(body);

            const screen = new THREE.Mesh(new THREE.BoxGeometry(0.74, 1.54, 0.01), screenMat);
            screen.position.z = 0.04;
            screen.userData = { isVRScreen: true };
            phoneGroup.add(screen);

            /* TAB HITBOXES */
            const tabHitboxGeo = new THREE.PlaneGeometry(0.24, 0.15);
            const tabHitboxMat = new THREE.MeshBasicMaterial({ visible: false });

            const tabLog = new THREE.Mesh(tabHitboxGeo, tabHitboxMat);
            tabLog.position.set(-0.25, 0.6, 0.05);
            tabLog.userData = { isVRScreen: true, tab: 'tab-log' };
            phoneGroup.add(tabLog);

            const tabChat = new THREE.Mesh(tabHitboxGeo, tabHitboxMat);
            tabChat.position.set(0, 0.6, 0.05);
            tabChat.userData = { isVRScreen: true, tab: 'tab-chat' };
            phoneGroup.add(tabChat);

            const tabManual = new THREE.Mesh(tabHitboxGeo, tabHitboxMat);
            tabManual.position.set(0.25, 0.6, 0.05);
            tabManual.userData = { isVRScreen: true, tab: 'tab-manual' };
            phoneGroup.add(tabManual);

            phonePivot.add(phoneGroup);
            phonePivot.rotation.y = PIVOT_ANGLE;
            container.add(phonePivot);

            // --- HAND ---
            const handGroup = new THREE.Group();
            const palm = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.9, 0.2), skinMat);
            palm.castShadow = palm.receiveShadow = true;
            handGroup.add(palm);

            const fingerLengths = [0.42, 0.45, 0.40, 0.32];
            const spreadAngles = [-0.08, 0, 0.08, 0.15];

            for (let i = 0; i < 4; i++) {
                const f1 = createBone(0.08, fingerLengths[i], skinMat);
                f1.group.position.set(-0.35, 0.3 - (i * 0.22), 0);
                f1.group.rotation.set(Math.PI / 2 - 0.1, spreadAngles[i], 0.15);

                const f2 = createBone(0.07, fingerLengths[i] * 0.6, skinMat);
                f2.group.position.y = f1.length;
                f2.group.rotation.set(0.1, 0, -0.4 - FINGER_OFFSETS[i]);

                const f3 = createBone(0.06, fingerLengths[i] * 0.35, skinMat);
                f3.group.position.y = f2.length;
                f3.group.rotation.set(0.1, 0, -0.7 - FINGER_OFFSETS[i]);

                f2.group.add(f3.group);
                f1.group.add(f2.group);
                handGroup.add(f1.group);
            }

            const t1 = createBone(0.1, 0.38, skinMat);
            t1.group.position.set(0.42, -0.05, 0.1);
            t1.group.rotation.set(0.25, -0.35, -0.05);
            const t2 = createBone(0.09, 0.3, skinMat);
            t2.group.position.y = t1.length;
            t2.group.rotation.set(0.15, 0, 0.05);
            t1.group.add(t2.group);
            handGroup.add(t1.group);

            handGroup.position.set(0.15, -0.2, -0.4);
            handGroup.rotation.set(-0.25, -0.35, 0);
            container.add(handGroup);

            return { container, screenMat, phoneGroup };
        }

        const vRPhoneScale = 0.15;
        const wristModule = createLowPolyHandModel();
        wristModule.container.scale.set(vRPhoneScale, vRPhoneScale, vRPhoneScale);
        wristModule.container.position.set(0.0046, -0.0222, -0.0274);
        wristModule.container.rotation.set(4.0533, 1.6987, 0.1865);

        const wristMenuCanvas = document.createElement('canvas');
        wristMenuCanvas.width = 128; wristMenuCanvas.height = 128;
        const wristCtx = wristMenuCanvas.getContext('2d');
        wristCtx.fillStyle = '#6B4226'; wristCtx.fillRect(0, 0, 128, 128);
        wristCtx.fillStyle = '#ffeb3b'; wristCtx.font = 'bold 80px sans-serif';
        wristCtx.textAlign = 'center'; wristCtx.textBaseline = 'middle';
        wristCtx.fillText('‚ò∞', 64, 64);

        const wristMenuMat = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(wristMenuCanvas) });
        const wristMenuMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), wristMenuMat);
        wristMenuMesh.position.set(0, 0.1, 0.1);
        wristMenuMesh.rotation.x = -Math.PI / 3;
        wristMenuMesh.userData = { isMenuBtn: true, action: 'show_menu' };

        const wristGroup = new THREE.Group();
        wristGroup.add(wristModule.container);
        wristGroup.add(wristMenuMesh);
        wristGroup.visible = false;

        let dominantController = null;
        let vrPhoneScroll = 0;
        let vrPhoneCanvas = document.createElement('canvas');
        vrPhoneCanvas.width = 512;
        vrPhoneCanvas.height = 1024;
        let vrPhoneCtx = vrPhoneCanvas.getContext('2d');
        wristModule.screenMat.map = new THREE.CanvasTexture(vrPhoneCanvas);

        window.updateVRPhoneScreen = function () {
            if (!wristGroup.visible) return;
            vrPhoneCtx.fillStyle = '#4A2E15';
            vrPhoneCtx.fillRect(0, 0, 512, 1024);

            vrPhoneCtx.fillStyle = lastUserSelectedTabId === 'tab-log' ? '#9A6E45' : '#4A2E15';
            vrPhoneCtx.fillRect(0, 0, 170, 80);
            vrPhoneCtx.fillStyle = lastUserSelectedTabId === 'tab-chat' ? '#9A6E45' : '#4A2E15';
            vrPhoneCtx.fillRect(170, 0, 172, 80);
            vrPhoneCtx.fillStyle = lastUserSelectedTabId === 'tab-manual' ? '#9A6E45' : '#4A2E15';
            vrPhoneCtx.fillRect(342, 0, 170, 80);

            vrPhoneCtx.fillStyle = '#fff';
            vrPhoneCtx.font = 'bold 32px sans-serif';
            vrPhoneCtx.textAlign = 'center';
            vrPhoneCtx.textBaseline = 'middle';
            vrPhoneCtx.fillText('‚öîÔ∏è log', 85, 40);
            vrPhoneCtx.fillText('üí¨ net', 256, 40);
            vrPhoneCtx.fillText('üìñ ebook', 427, 40);

            vrPhoneCtx.fillStyle = '#ffffff';
            vrPhoneCtx.fillRect(0, 80, 512, 944);

            vrPhoneCtx.save();
            vrPhoneCtx.beginPath();
            vrPhoneCtx.rect(0, 80, 512, 944);
            vrPhoneCtx.clip();

            if (lastUserSelectedTabId === 'tab-manual') {
                vrPhoneCtx.fillStyle = '#333';
                vrPhoneCtx.font = 'bold 40px sans-serif';
                vrPhoneCtx.textAlign = 'left';
                vrPhoneCtx.fillText('üìñ Guia R√°pido', 30, 140 + vrPhoneScroll);
                vrPhoneCtx.font = '28px sans-serif';
                let y = 200 + vrPhoneScroll;
                const lines = [
                    "O Alvo: Entre na Toca para vencer!",
                    "For√ßa: Elefante > Le√£o > Tigre ... Rato",
                    "O Segredo: O Rato captura o Elefante!",
                    "√Ågua: S√≥ o Rato pode entrar no rio.",
                    "Salto: Le√£o e Tigre saltam sobre rios.",
                    "Armadilha: For√ßa cai a 0 na armadilha!"
                ];
                lines.forEach(l => {
                    vrPhoneCtx.fillText('‚Ä¢ ' + l, 30, y);
                    y += 50;
                });
            } else if (lastUserSelectedTabId === 'tab-log') {
                const logEntries = Array.from(document.getElementById('tab-log').children);
                let y = 140 + vrPhoneScroll;
                vrPhoneCtx.font = '28px sans-serif';
                vrPhoneCtx.textAlign = 'left';
                logEntries.forEach(el => {
                    vrPhoneCtx.fillStyle = el.innerHTML.includes('E52222') ? '#E52222' : '#25A02B';
                    vrPhoneCtx.fillText(el.innerText.replace('‚ûî', '->'), 30, y);
                    y += 45;
                });
            } else if (lastUserSelectedTabId === 'tab-chat') {
                const chatEntries = Array.from(document.getElementById('tab-chat').children);
                let y = 140 + vrPhoneScroll;
                vrPhoneCtx.textAlign = 'left';
                chatEntries.forEach(el => {
                    const textLines = el.innerText.split('\n');
                    vrPhoneCtx.fillStyle = el.innerHTML.includes('E52222') ? '#E52222' : '#25A02B';
                    if (textLines[0]) {
                        vrPhoneCtx.font = 'bold 28px sans-serif';
                        vrPhoneCtx.fillText(textLines[0], 30, y);
                        y += 35;
                    }
                    vrPhoneCtx.fillStyle = '#333';
                    vrPhoneCtx.font = '26px sans-serif';
                    for (let i = 1; i < textLines.length; i++) {
                        if (textLines[i].trim() !== '') {
                            vrPhoneCtx.fillText(textLines[i].trim(), 30, y);
                            y += 35;
                        }
                    }
                    y += 20;
                });
            }
            vrPhoneCtx.restore();
            wristModule.screenMat.map.needsUpdate = true;
        }

        window.setDominantHand = function (controller) {
            // Se for nulo, for√ßamos a releitura
            if (controller && dominantController === controller) return;
            dominantController = controller;

            // Ativa no wristGroup apenas se a cena for GAME, conforme o feedback 2
            wristGroup.visible = (currentScene === 'game');

            // Oculta/Exibe os controles de fallback ou factoryModels
            // XRControllerModelFactory usually creates a Scene or Object3D, not just Meshes. 
            // Better to find by filtering out our fallback and wristGroup.
            const factory1 = grip1.children.find(c => c !== controller1Fallback && c !== wristGroup);
            const factory2 = grip2.children.find(c => c !== controller2Fallback && c !== wristGroup);

            if (controller === controller1) { // Direito domina, Esquerdo (grip2) recebe telefone
                grip2.add(wristGroup);
                // Swapped as per user request (base model is likely left hand naturally)
                wristModule.phoneGroup.scale.x = 1;
                wristModule.container.scale.x = vRPhoneScale;

                // Exibe comando dominante, oculta comando com celular
                if (controller1Fallback) controller1Fallback.visible = true;
                if (factory1) factory1.visible = true;

                if (currentScene === 'game') {
                    if (controller2Fallback) controller2Fallback.visible = false;
                    if (factory2) factory2.visible = false;
                } else {
                    if (controller2Fallback) controller2Fallback.visible = true;
                    if (factory2) factory2.visible = true;
                }

            } else if (controller === controller2) { // Esquerdo domina, Direito (grip1) recebe telefone
                grip1.add(wristGroup);
                // Swapped as per user request (base model is likely left hand naturally)
                wristModule.phoneGroup.scale.x = -1;
                wristModule.container.scale.x = -vRPhoneScale;

                // Exibe comando dominante, oculta comando com celular
                if (controller2Fallback) controller2Fallback.visible = true;
                if (factory2) factory2.visible = true;

                if (currentScene === 'game') {
                    if (controller1Fallback) controller1Fallback.visible = false;
                    if (factory1) factory1.visible = false;
                } else {
                    if (controller1Fallback) controller1Fallback.visible = true;
                    if (factory1) factory1.visible = true;
                }
            }
            window.updateVRPhoneScreen();
        };

        controller1.addEventListener('selectstart', () => {
            controller1Selected = true;
            if (window.setDominantHand) window.setDominantHand(controller1);
        });
        controller1.addEventListener('selectend', () => { controller1Selected = false; });
        controller2.addEventListener('selectstart', () => {
            controller2Selected = true;
            if (window.setDominantHand) window.setDominantHand(controller2);
        });
        controller2.addEventListener('selectend', () => { controller2Selected = false; });

        controller1.addEventListener('squeezestart', () => grip1Active = true);
        controller1.addEventListener('squeezeend', () => grip1Active = false);
        controller2.addEventListener('squeezestart', () => grip2Active = true);
        controller2.addEventListener('squeezeend', () => grip2Active = false);

        function onSelectXR(event) {
            initAudio(); const controller = event.target;
            isTransitioningCamera = false;
            resetIdleTime();
            if (controller1Selected && controller2Selected) return;
            if (isARSession && !isARPlaced) {
                if (reticle.visible) {
                    const arPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
                    gameGroup.position.copy(arPos);
                    gameGroup.scale.set(0.3, 0.3, 0.3);

                    gameGroup.userData.targetY = arPos.y;
                    gameGroup.userData.targetScale = 0.3;

                    isARPlaced = true; reticle.visible = false; document.getElementById('ar-overlay').style.display = 'none';
                }
                return;
            }
            const tempMatrix = new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            raycaster.camera = camera;

            let intersectables = [];
            if (currentScene === 'menu') intersectables = menuGroup.children;
            else if (currentScene === 'local_menu') intersectables = localMenuGroup.children;
            else if (currentScene === 'options') intersectables = optionsGroup.children;
            else if (currentScene === 'about') intersectables = aboutGroup.children;
            else if (currentScene === 'multiplayer') intersectables = multiplayerGroup.children;
            else if (currentScene === 'game') intersectables = [...gameGroup.children, ...hudGroup.children, wristGroup];

            const intersects = raycaster.intersectObjects(intersectables, true)
                .filter(hit => {
                    if (!hit.object.visible) return false;
                    const ud = hit.object.userData; if (!ud) return false;
                    if (currentScene === 'game') {
                        if (ud.isPiece && ud.pieceData === selectedPiece) return false;
                        return (ud.isPiece && ud.pieceData && !ud.pieceData.isDead) || ud.isTile || ud.isHUDButton;
                    }
                    else return ud.isMenuBtn;
                });
            if (intersects.length > 0) handleInteraction(intersects[0]);
        }
        controller1.addEventListener('select', onSelectXR);
        controller2.addEventListener('select', onSelectXR);

        renderer.xr.addEventListener('sessionstart', (e) => {
            isARSession = renderer.xr.getSession().mode === 'immersive-ar';
            if (isARSession) {
                document.getElementById('ar-overlay').style.display = 'block';
                gameGroup.position.set(0, -1000, 0);
                gameGroup.userData.targetY = -1000;
                isARPlaced = false;
                scene.background = null;
            }
            else {
                gameGroup.position.set(0, 0.6, -2.0);
                gameGroup.scale.set(0.3, 0.3, 0.3);

                gameGroup.userData.targetY = 0.6;
                gameGroup.userData.targetScale = 0.3;

                scene.background = bgTexture;
            }
        });
        renderer.xr.addEventListener('sessionend', () => {
            isARSession = false; hitTestSourceRequested = false; hitTestSource = null;
            document.getElementById('ar-overlay').style.display = 'none';
            gameGroup.position.set(0, 0, 0); gameGroup.scale.set(1, 1, 1);
            scene.background = bgTexture;
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateHUDPosition();
        });

        switchScene('menu');
        gameGroup.userData.targetY = gameGroup.position.y;
        gameGroup.userData.targetScale = gameGroup.scale.y;

        const clock = new THREE.Clock();
        const emissiveOff = new THREE.Color(0x000000);

        function animate() { renderer.setAnimationLoop(render); }

        function handleXRInput(delta) {
            if (!renderer.xr.isPresenting) return;

            if (grip1Active && grip2Active) {
                resetIdleTime();
                if (!isDoubleGripping) {
                    isDoubleGripping = true;
                    isSingleGripping = false;
                    initialGripM.addVectors(grip1.position, grip2.position).multiplyScalar(0.5);
                    initialGripV.subVectors(grip2.position, grip1.position);
                    initialGripDist = initialGripV.length();
                    initialGripMatrix.copy(gameGroup.matrix);
                }

                const currentM = new THREE.Vector3().addVectors(grip1.position, grip2.position).multiplyScalar(0.5);
                const currentV = new THREE.Vector3().subVectors(grip2.position, grip1.position);
                const currentDist = currentV.length();

                if (initialGripDist > 0.01 && currentDist > 0.01) {
                    const scale = currentDist / initialGripDist;
                    const q = new THREE.Quaternion().setFromUnitVectors(
                        initialGripV.clone().normalize(),
                        currentV.clone().normalize()
                    );

                    const m = new THREE.Matrix4();
                    m.makeTranslation(currentM.x, currentM.y, currentM.z);
                    m.multiply(new THREE.Matrix4().makeRotationFromQuaternion(q));
                    m.scale(new THREE.Vector3(scale, scale, scale));
                    m.multiply(new THREE.Matrix4().makeTranslation(-initialGripM.x, -initialGripM.y, -initialGripM.z));
                    m.multiply(initialGripMatrix);

                    gameGroup.matrix.copy(m);
                    gameGroup.matrix.decompose(gameGroup.position, gameGroup.quaternion, gameGroup.scale);

                    gameGroup.scale.clampScalar(0.05, 10.0);

                    gameGroup.userData.targetScale = gameGroup.scale.x;
                    gameGroup.userData.targetY = gameGroup.position.y;
                }
            } else if (grip1Active || grip2Active) {
                resetIdleTime();
                if (isDoubleGripping) {
                    isDoubleGripping = false;
                    isSingleGripping = false;
                }
                const activeCtrl = grip1Active ? grip1 : grip2;
                if (!isSingleGripping) {
                    isSingleGripping = true;
                    activeSingleController = activeCtrl;
                    initialSinglePanPos.copy(activeCtrl.position);
                    initialGameGroupPos.copy(gameGroup.position);
                } else if (activeSingleController === activeCtrl) {
                    const panDelta = new THREE.Vector3().subVectors(activeCtrl.position, initialSinglePanPos);
                    gameGroup.position.copy(initialGameGroupPos).add(panDelta);
                    gameGroup.userData.targetY = gameGroup.position.y;
                }
            } else {
                isDoubleGripping = false;
                isSingleGripping = false;
            }

            if (!isDoubleGripping) {
                const session = renderer.xr.getSession();
                if (session && session.inputSources) {
                    for (const source of session.inputSources) {
                        if (source.gamepad && source.gamepad.axes.length >= 4) {
                            const thumbstickX = source.gamepad.axes[2];
                            const thumbstickY = source.gamepad.axes[3];

                            const isPhoneHand = dominantController && (
                                (dominantController === controller1 && source.handedness === 'left') ||
                                (dominantController === controller2 && source.handedness === 'right')
                            );

                            if (false && isPhoneHand && (Math.abs(thumbstickX) > 0.1 || Math.abs(thumbstickY) > 0.1)) {
                                const isSqueeze = source.gamepad.buttons[1] && source.gamepad.buttons[1].pressed;
                                const isTrigger = source.gamepad.buttons[0] && source.gamepad.buttons[0].pressed;

                                if (!isSqueeze && !isTrigger) {
                                    wristModule.container.position.x += thumbstickX * 0.002;
                                    wristModule.container.position.y -= thumbstickY * 0.002;
                                } else if (isSqueeze && !isTrigger) {
                                    wristModule.container.position.z -= thumbstickY * 0.002;
                                    wristModule.container.rotation.z -= thumbstickX * 0.03;
                                } else if (isTrigger) {
                                    wristModule.container.rotation.x -= thumbstickY * 0.03;
                                    wristModule.container.rotation.y -= thumbstickX * 0.03;
                                }

                                console.log(`[VR ADJUST] \nposition.set(${wristModule.container.position.x.toFixed(4)}, ${wristModule.container.position.y.toFixed(4)}, ${wristModule.container.position.z.toFixed(4)});\nrotation.set(${wristModule.container.rotation.x.toFixed(4)}, ${wristModule.container.rotation.y.toFixed(4)}, ${wristModule.container.rotation.z.toFixed(4)});\n`);
                                continue;
                            }

                            if (Math.abs(thumbstickX) > 0.1) {
                                gameGroup.rotation.y -= thumbstickX * delta * 2;
                                resetIdleTime();
                            }
                            if (Math.abs(thumbstickY) > 0.1) {
                                // Scroll handling for VR smartphone
                                const sourcesArray = Array.from(session.inputSources);
                                const cIndex = sourcesArray.indexOf(source);
                                const aimSpace = renderer.xr.getController(cIndex) || camera;
                                raycaster.ray.origin.setFromMatrixPosition(aimSpace.matrixWorld);
                                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(aimSpace.quaternion);
                                raycaster.ray.direction.copy(fwd);
                                const hits = raycaster.intersectObject(wristGroup, true);
                                if (hits.length > 0 && hits[0].object.userData.isVRScreen) {
                                    vrPhoneScroll += thumbstickY * delta * 500;
                                    if (vrPhoneScroll > 0) vrPhoneScroll = 0;
                                    if (window.updateVRPhoneScreen) window.updateVRPhoneScreen();
                                } else {
                                    gameGroup.rotation.x -= thumbstickY * delta * 2;
                                }
                                resetIdleTime();
                            }
                        }
                    }
                }
            }
        }

        function render(timestamp, frame) {
            const delta = clock.getDelta(); const time = clock.getElapsedTime();

            handleXRInput(delta);

            if (restarting) {
                const isTransitionDone = Math.abs(gameGroup.scale.y - gameGroup.userData.targetScale) < 0.001;
                if (isTransitionDone) {
                    initPieces();
                    selectedPiece = null;
                    clearHighlights();
                    document.getElementById('tab-log').innerHTML = '';
                    document.getElementById('tab-chat').innerHTML = '';

                    window.hasLoggedFirstMove = false;
                    const tabBtnManual = document.querySelectorAll('.phone-tab')[2];
                    window.openPhoneTab('tab-manual', tabBtnManual, false);

                    restarting = false;
                }
            }

            if (currentScene === 'game' && gameMode === 'cpu' && engine.currentTurn === 0 && !isCPUThinking && engine.winner === null && !restarting) {
                const isAnyPieceMoving = pieceMeshes.some(p => p.isMoving || p.isMorphing || p.squashTimer > 0 || p.trapAnimState > 0 || p.captureAnimTimer > 0 || p.isDying);
                if (!isAnyPieceMoving) {
                    isCPUThinking = true;
                    setTimeout(makeCPUMove, 1000);
                }
            }

            // =====================================
            // Dica 1: Fofocas Idle das Pe√ßas & Respostas (Retrucagens)
            // =====================================
            if (currentScene === 'game' && tipsEnabled && engine.winner === null && !restarting) {
                idleTime += delta;
                const alivePieces = pieceMeshes.filter(p => !p.isDead && !p.isDying && !p.isMoving && !p.isMorphing && p.trapAnimState === 0);

                for (let i = pendingReplies.length - 1; i >= 0; i--) {
                    const pr = pendingReplies[i];
                    if (time >= pr.triggerTime) {
                        if (!pr.piece.isDead && !pr.piece.isDying) {
                            spawnSpeechBubble(pr.piece, pr.text, pr.replyTo);
                            lastGossipTime = time;
                        }
                        pendingReplies.splice(i, 1);
                    }
                }

                // Ajuste Din√¢mico: Se o E-book estiver aberto, as pe√ßas "calam-se" por 60s
                let currentIdleThreshold = 20.0;
                const manualTab = document.getElementById('tab-manual');
                if (manualTab && manualTab.classList.contains('active')) {
                    currentIdleThreshold = 60.0;
                }

                if (idleTime > currentIdleThreshold && (time - lastGossipTime > 8.0) && pendingReplies.length === 0) {
                    if (alivePieces.length > 0) {
                        const p = alivePieces[Math.floor(Math.random() * alivePieces.length)];
                        const lines = window.i18n(`dialogues.gossips.${p.rank}`);
                        const randIdx = Math.floor(Math.random() * lines.length);
                        const textTpl = lines[randIdx];

                        const enemyEmoji = p.team === 0 ? 'üü¢' : 'üî¥';
                        const finalGossipText = textTpl.replace('{0}', enemyEmoji);

                        spawnSpeechBubble(p, finalGossipText);
                        lastGossipTime = time;

                        window.autoOpenChat();

                        const replyData = { nickname: getPieceNickname(p), text: finalGossipText };

                        // Dynamic Replies based on caller piece and generated random message index
                        if ((p.rank === 6 || p.rank === 7) && randIdx === 0) {
                            const enemyRat = alivePieces.find(ep => ep.rank === 1 && ep.team !== p.team);
                            if (enemyRat) pendingReplies.push({ piece: enemyRat, text: window.i18n('dialogues.replies.water_threat'), triggerTime: time + 3.0, replyTo: replyData });
                        } else if (p.rank === 1 && randIdx === 1) {
                            const enemyElephant = alivePieces.find(ep => ep.rank === 8 && ep.team !== p.team);
                            if (enemyElephant) pendingReplies.push({ piece: enemyElephant, text: window.i18n('dialogues.replies.elephant_fear'), triggerTime: time + 3.0, replyTo: replyData });
                        } else if (p.rank === 8 && randIdx === 1) {
                            const enemyRat = alivePieces.find(ep => ep.rank === 1 && ep.team !== p.team);
                            if (enemyRat) pendingReplies.push({ piece: enemyRat, text: window.i18n('dialogues.replies.rat_threat'), triggerTime: time + 3.0, replyTo: replyData });
                        } else if (p.rank === 1 && (randIdx === 0 || randIdx === 2)) {
                            const enemyCat = alivePieces.find(ep => (ep.rank === 6 || ep.rank === 7) && ep.team !== p.team);
                            if (enemyCat) pendingReplies.push({ piece: enemyCat, text: window.i18n('dialogues.replies.cat_threat'), triggerTime: time + 3.0, replyTo: replyData });
                        }
                    }
                }
            }

            for (let i = activeDialogues.length - 1; i >= 0; i--) {
                const d = activeDialogues[i];
                d.life -= delta;
                d.timer += delta;

                let scale = 4.5;
                if (d.timer < 0.2) {
                    scale = 4.5 * (d.timer / 0.2);
                } else if (d.life < 0.3) {
                    scale = 4.5 * (d.life / 0.3);
                    d.sprite.material.opacity = d.life * 3.3;
                }

                d.sprite.scale.set(scale, scale, 1);

                if (d.life <= 0) {
                    d.piece.mesh.remove(d.sprite);
                    activeDialogues.splice(i, 1);
                }
            }

            if (currentScene === 'game') {
                const statusDiv = document.getElementById('status');
                let newText = "";
                let newColor = "";

                if (engine.winner !== null) {
                    newText = engine.winner === 1 ? window.i18n('ui.win_green') : window.i18n('ui.win_red');
                    newColor = "#ffeb3b";
                } else {
                    if (gameMode === 'cpu') newText = engine.currentTurn === 1 ? window.i18n('ui.turn_p_green') : window.i18n('ui.turn_cpu_red');
                    else if (gameMode === 'pvp') newText = engine.currentTurn === 1 ? window.i18n('ui.turn_green') : window.i18n('ui.turn_red');
                    else if (gameMode === 'multi') newText = engine.currentTurn === myTeamId ? window.i18n('ui.turn_yours') : window.i18n('ui.turn_opp');
                    newColor = engine.currentTurn === 1 ? "#25A02B" : "#E52222";
                }

                if (statusDiv.innerText !== newText) {
                    statusDiv.innerText = newText;
                    statusDiv.style.color = newColor;
                }
            }

            if (controls.userData) {
                currentGyroOffset.lerp(targetGyroOffset, 5 * delta);
                const finalTarget = controls.userData.target.clone();
                if (!renderer.xr.isPresenting) {
                    finalTarget.x += currentGyroOffset.x;
                    finalTarget.z += currentGyroOffset.y;
                }
                controls.target.lerp(finalTarget, 4 * delta);
            }

            if (isTransitioningCamera) {
                camera.position.lerp(camera.userData.targetPos, 4 * delta);
                if (camera.position.distanceTo(camera.userData.targetPos) < 0.05) {
                    isTransitioningCamera = false;
                }
            }

            if (!isPinching && !isDoubleGripping) {
                const s = THREE.MathUtils.lerp(gameGroup.scale.y, gameGroup.userData.targetScale, 4 * delta);
                if (Math.abs(s - gameGroup.userData.targetScale) > 0.001) {
                    gameGroup.scale.set(s, s, s);
                }
            }
            if (!isDoubleGripping && !isSingleGripping) {
                gameGroup.position.y = THREE.MathUtils.lerp(gameGroup.position.y, gameGroup.userData.targetY, 4 * delta);
            }

            const isFlipped = Math.abs(gameGroup.rotation.y) > 0.1;
            let targetRedLight = engine.currentTurn === 0 ? 6.0 : 1.8;
            let targetGreenLight = engine.currentTurn === 1 ? 6.0 : 1.8;

            if (isFlipped) {
                targetRedLight = engine.currentTurn === 1 ? 6.0 : 1.8;
                targetGreenLight = engine.currentTurn === 0 ? 6.0 : 1.8;
            }

            lightRedSide.intensity = THREE.MathUtils.lerp(lightRedSide.intensity, targetRedLight, delta * 4);
            lightGreenSide.intensity = THREE.MathUtils.lerp(lightGreenSide.intensity, targetGreenLight, delta * 4);

            bannerRed.banner.visible = engine.currentTurn === 0;
            bannerGreen.banner.visible = engine.currentTurn === 1;

            [bannerRed, bannerGreen].forEach(b => {
                if (!b.banner.visible) return;
                const cloth = b.cloth;
                const posAttr = cloth.geometry.attributes.position;
                const origVerts = cloth.userData.originalVertices;
                const bannerHeight = pieceHeight * 3;
                for (let i = 0; i < posAttr.count; i++) {
                    const origP = origVerts[i];
                    const amplitude = Math.pow(-origP.y / bannerHeight, 2) * 0.2;
                    const wave = Math.sin(origP.y * 2.0 + time * 3.0) * amplitude;
                    posAttr.setZ(i, origP.z + wave);
                }
                posAttr.needsUpdate = true;
                cloth.geometry.computeVertexNormals();
            });

            if (selectedPiece && currentScene === 'game') {
                auraLight.intensity = THREE.MathUtils.lerp(auraLight.intensity, 4.0, delta * 10);
                auraLight.color.copy(selectedPiece.baseTeamColor);

                const worldPos = new THREE.Vector3();
                selectedPiece.mesh.getWorldPosition(worldPos);

                auraLight.position.x = THREE.MathUtils.lerp(auraLight.position.x, worldPos.x, delta * 15);
                auraLight.position.z = THREE.MathUtils.lerp(auraLight.position.z, worldPos.z, delta * 15);
                auraLight.position.y = worldPos.y + 0.5;
            } else { auraLight.intensity = THREE.MathUtils.lerp(auraLight.intensity, 0, delta * 10); }

            tileMeshes.forEach(tile => {
                if (tile.userData.isWater) {
                    const posAttr = tile.geometry.attributes.position, origVerts = tile.userData.originalVertices;
                    const worldX = tile.position.x, worldZ = tile.position.z;
                    for (let i = 0; i < posAttr.count; i++) {
                        const origP = origVerts[i];
                        if (origP.y > 0.05) {
                            const wave = Math.sin((worldX + origP.x) * 3 + time * 2) * 0.04 + Math.cos((worldZ + origP.z) * 3 + time * 1.5) * 0.04;
                            posAttr.setY(i, origP.y + wave);
                        }
                    }
                    posAttr.needsUpdate = true; tile.geometry.computeVertexNormals();
                }
            });

            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const p = activeParticles[i];
                p.mesh.position.x += p.vx * delta; p.mesh.position.y += p.vy * delta; p.mesh.position.z += p.vz * delta;
                p.vy -= 15.0 * delta; p.life -= delta * 0.5; p.mesh.material.opacity = p.life;
                if (p.life <= 0) { gameGroup.remove(p.mesh); activeParticles.splice(i, 1); }
            }

            const cameraLocalPos = gameGroup.worldToLocal(camera.position.clone());
            const camAngle = Math.atan2(cameraLocalPos.x, cameraLocalPos.z);

            let angleDiff = camAngle - targetSnapAngle;
            angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));

            if (Math.abs(angleDiff) > (Math.PI / 4) + 0.15) {
                targetSnapAngle = Math.round(camAngle / (Math.PI / 2)) * (Math.PI / 2);
            }

            trapTextMat.map.rotation = targetSnapAngle;

            [menuGroup, localMenuGroup, optionsGroup, aboutGroup, multiplayerGroup].forEach(grp => {
                if (grp.visible) {
                    grp.lookAt(camera.position);

                    const menuBaseY = renderer.xr.isPresenting ? (camera.position.y || 1.5) : 2.5;
                    grp.position.y = menuBaseY + Math.sin(time * 2) * 0.1;
                }
            });

            pieceMeshes.forEach(pd => {
                if (pd.isDead) return;
                if (pd.isMoving) {
                    pd.moveProgress += delta * 2.5;
                    if (pd.moveProgress >= 1.0) {
                        pd.moveProgress = 1.0; pd.isMoving = false; pd.squashTimer = 1.0;
                        if (pd.capturedPiece) { pd.capturedPiece.isDying = true; playSound('squash'); pd.captureAnimTimer = 0.3; } else if (pd.isVictoryPending) { pd.captureAnimTimer = 0.1; }
                        const enemyTeam = pd.team === 0 ? 1 : 0;
                        if (engine.isTrap(pd.gridX, pd.gridY, enemyTeam)) {
                            if (pd.trapNumberVisual > 0) { pd.trapAnimState = 1; pd.trapTimer = 0.15; pd.isInDanger = engine.pieces.some(enemy => enemy.team === enemyTeam && engine.isValidMove(enemy, enemy.gridX, enemy.gridY, pd.gridX, pd.gridY)); }
                        } else if (pd.trapNumberVisual < pd.rank) { pd.trapAnimState = 3; pd.trapTimer = 0.15; }
                    }
                    const t = pd.moveProgress; const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const yOffset = Math.sin(t * Math.PI) * 1.2;
                    pd.mesh.position.lerpVectors(pd.startPos, pd.targetPos, easeT); pd.mesh.position.y += yOffset;
                    const stretch = 1.0 + Math.abs(Math.cos(t * Math.PI)) * 0.4;
                    pd.mesh.scale.set(1.0 / Math.sqrt(stretch), stretch, 1.0 / Math.sqrt(stretch));
                } else if (pd.squashTimer > 0) {
                    pd.squashTimer -= delta * 6.0; if (pd.squashTimer < 0) pd.squashTimer = 0;
                    const wobble = Math.sin(pd.squashTimer * Math.PI * 5) * pd.squashTimer * 0.4;
                    pd.mesh.scale.set(1.0 + wobble, 1.0 - wobble, 1.0 + wobble);
                } else if (pd.isDying) {
                    pd.mesh.scale.y = THREE.MathUtils.lerp(pd.mesh.scale.y, 0.05, 15 * delta);
                    pd.mesh.scale.x = THREE.MathUtils.lerp(pd.mesh.scale.x, 2.0, 15 * delta);
                    pd.mesh.scale.z = THREE.MathUtils.lerp(pd.mesh.scale.z, 2.0, 15 * delta);
                    if (pd.mesh.scale.y < 0.08) {
                        pd.mesh.visible = false;
                        pd.isDying = false;
                        pd.isDead = true;

                        pd.isMorphing = false;
                        pd.isBigAnim = false;
                        pd.squashTimer = 0;
                        pd.trapAnimState = 0;
                        pd.captureAnimTimer = 0;

                        if (engine.getPieceAt(pd.gridX, pd.gridY) === pd) {
                            engine.board[pd.gridX][pd.gridY] = null;
                        }
                    }
                } else {
                    pd.mesh.scale.set(1, 1, 1);
                    if (pd.rank !== 1 || !engine.isWater(pd.gridX, pd.gridY)) {
                        pd.mesh.position.lerp(pd.targetPos, 10 * delta);
                        pd.mesh.rotation.x = THREE.MathUtils.lerp(pd.mesh.rotation.x, 0, delta * 5);
                        pd.mesh.rotation.z = THREE.MathUtils.lerp(pd.mesh.rotation.z, 0, delta * 5);
                    } else {
                        const wave = Math.sin(pd.mesh.position.x * 2.5 + time * 2.2) * 0.05 + Math.cos(pd.mesh.position.z * 2.5 + time * 1.8) * 0.05;
                        const floatingY = 0.25 + wave;
                        const targetPosWithWave = new THREE.Vector3(pd.targetPos.x, floatingY, pd.targetPos.z);
                        pd.mesh.position.lerp(targetPosWithWave, 4 * delta);
                        const targetRotX = Math.cos(time * 1.8 + pd.mesh.position.z * 2) * 0.25;
                        const targetRotZ = Math.sin(time * 2.2 + pd.mesh.position.x * 2) * 0.25;
                        pd.mesh.rotation.x = THREE.MathUtils.lerp(pd.mesh.rotation.x, targetRotX, delta * 4);
                        pd.mesh.rotation.z = THREE.MathUtils.lerp(pd.mesh.rotation.z, targetRotZ, delta * 4);
                    }
                }

                if (pd.trapAnimState === 1) {
                    pd.trapTimer -= delta;
                    if (pd.trapTimer <= 0) {
                        pd.trapNumberVisual--;
                        if (pd.trapNumberVisual >= 0) { updatePieceTopNumber(pd, pd.trapNumberVisual.toString()); playSound('beep'); pd.trapTimer = 0.15; } else {
                            pd.trapAnimState = 2; pd.isMorphing = true; pd.isBigAnim = false; pd.morphTimer = 2.0;
                            if (pd.isInDanger) { playSound('nervous'); spawnCustomParticles(['üíß', 'üò∞', 'üò±', '‚ùó'], pd.targetPos, 15); }
                            else { playSound('cheeky'); spawnCustomParticles(['üòà', 'üòº', 'üî•', 'üéµ'], pd.targetPos, 15); }
                        }
                    }
                } else if (pd.trapAnimState === 2) { if (!pd.isMorphing) pd.trapAnimState = 0; } else if (pd.trapAnimState === 3) {
                    pd.trapTimer -= delta;
                    if (pd.trapTimer <= 0) {
                        pd.trapNumberVisual++;
                        if (pd.trapNumberVisual <= pd.rank) { updatePieceTopNumber(pd, pd.trapNumberVisual.toString()); playSound('beep-up'); pd.trapTimer = 0.15; } else { pd.trapNumberVisual = pd.rank; pd.trapAnimState = 0; }
                    }
                }

                if (pd.captureAnimTimer > 0) {
                    pd.captureAnimTimer -= delta;
                    if (pd.captureAnimTimer <= 0) {
                        pd.captureAnimTimer = 0; pd.isMorphing = true; pd.isBigAnim = true;
                        pd.morphTimer = pd.isVictoryPending ? Infinity : 2.5;
                        playSound('win'); spawnVictoryParticles(pd.rank, pd.targetPos);
                    }
                }

                if (pd.isMorphing && !pd.isDying && !pd.isMoving) {
                    pd.morphTimer -= delta;
                    if (pd.isBigAnim) { pd.cylinder.visible = false; pd.sprite.visible = true; pd.sprite.position.y = 1.5 + Math.sin(time * 6) * 0.1; pd.sprite.scale.lerp(new THREE.Vector3(3.5, 3.5, 1), 4 * delta); }
                    else { pd.cylinder.visible = true; pd.sprite.visible = true; pd.sprite.position.y = 1.0 + Math.sin(time * 6) * 0.1; pd.sprite.scale.set(1.0, 1.0, 1); }
                    if (pd.morphTimer <= 0 && !pd.isVictoryPending) { pd.isMorphing = false; pd.isBigAnim = false; pd.sprite.visible = false; pd.cylinder.visible = true; }
                } else if (!pd.isVictoryPending) {
                    pd.sprite.scale.set(1.5, 1.5, 1);
                    if (!pd.isDying && !pd.isBigAnim) { pd.cylinder.visible = true; pd.sprite.visible = false; }
                }

                if (!pd.isMorphing && !pd.isDying && !pd.isDead) pd.cylinder.material[1].map.rotation = targetSnapAngle - pd.cylinder.rotation.y;

                if (!pd.isDead && pd.cylinder && pd.cylinder.material) {
                    const isActiveTurn = (pd.team === engine.currentTurn);
                    const isSelected = (pd === selectedPiece);
                    const targetEmissive = new THREE.Color();

                    // CORRE√á√ÉO WEBXR: Emissividade mais suave nos √≥culos para evitar o efeito "Estouro" neon.
                    if (isSelected) {
                        const emissiveIntensity = renderer.xr.isPresenting ? 0.05 : 0.15;
                        targetEmissive.copy(pd.baseTeamColor).multiplyScalar(emissiveIntensity);
                    } else if (isActiveTurn) {
                        const turnIntensity = renderer.xr.isPresenting ? 0.03 : 0.12;
                        targetEmissive.copy(pd.baseTeamColor).multiplyScalar(turnIntensity);
                    } else { targetEmissive.copy(emissiveOff); }

                    pd.cylinder.material[0].emissive.lerp(targetEmissive, delta * 10);
                    pd.cylinder.material[1].emissive.lerp(targetEmissive, delta * 10);
                    pd.cylinder.material[2].emissive.lerp(targetEmissive, delta * 10);
                }
            });

            if (frame && isARSession && !isARPlaced) {
                const referenceSpace = renderer.xr.getReferenceSpace(), session = renderer.xr.getSession();
                if (!hitTestSourceRequested) { session.requestReferenceSpace('viewer').then((referenceSpace) => { session.requestHitTestSource({ space: referenceSpace }).then((source) => { hitTestSource = source; }); }); session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; }); hitTestSourceRequested = true; }
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) { reticle.visible = true; reticle.matrix.fromArray(hitTestResults[0].getPose(referenceSpace).transform.matrix); }
                    else reticle.visible = false;
                }
            }
            controls.update();
            if (titleGroup && titleGroup.userData && titleGroup.userData.update) {
                titleGroup.userData.update();
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('Service Worker registered successfully!', registration.scope);
                    })
                    .catch(err => {
                        console.error('Service Worker registration failed: ', err);
                    });
            });
        }
    </script>
</body>

</html>