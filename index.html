<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Selva: O Jogo de Xadrez Animal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        /* UI em HTML escondida por defeito, ativada apenas no Gameplay */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none; 
            flex-direction: column;
            justify-content: space-between;
        }
        #header {
            text-align: center;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        h1 { margin: 0; font-size: 24px; }
        #status { font-size: 18px; margin-top: 5px; font-weight: bold; color: #ffeb3b; }
        
        #controls {
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            pointer-events: auto;
        }
        #ar-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
    </style>
    <!-- Import Maps para Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui-container">
        <div id="header">
            <h1>Jungle Chess 3D</h1>
            <div id="status">Vez do Jogador Verde</div>
        </div>
        <div id="controls"></div>
    </div>
    <div id="ar-overlay">Toque na tela para posicionar o tabuleiro</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // ==========================================
        // ESTADOS DO JOGO (STATE MACHINE)
        // ==========================================
        let currentScene = 'menu'; // 'menu', 'options', 'about', 'game'
        let tipsEnabled = true;

        // ==========================================
        // DADOS DO JOGO E REGRAS
        // ==========================================
        const RANKS = {
            1: { name: "Rato", icon: "ðŸ­" }, 2: { name: "Gato", icon: "ðŸ±" }, 3: { name: "CÃ£o", icon: "ðŸ¶" }, 4: { name: "Lobo", icon: "ðŸº" },
            5: { name: "Leopardo", icon: "ðŸ†" }, 6: { name: "Tigre", icon: "ðŸ¯" }, 7: { name: "LeÃ£o", icon: "ðŸ¦" }, 8: { name: "Elefante", icon: "ðŸ˜" }
        };

        const PARTICLE_EMOJIS = {
            1: ['ðŸ§€', 'ðŸ¾', 'âœ¨'], 2: ['ðŸŸ', 'ðŸ¾', 'âœ¨'], 3: ['ðŸ¦´', 'ðŸ¾', 'âœ¨'], 4: ['ðŸº', 'ðŸ¾', 'âœ¨'],
            5: ['ðŸ¥©', 'ðŸ¾', 'âœ¨'], 6: ['ðŸ¥©', 'ðŸ¾', 'âœ¨'], 7: ['ðŸ‘‘', 'ðŸ¾', 'âœ¨'], 8: ['ðŸ¥œ', 'ðŸ’§', 'âœ¨']
        };

        const TEAMS = {
            0: { color: '#D32F2F', name: "Vermelho" }, 
            1: { color: '#388E3C', name: "Verde" }
        };

        const BOARD_COLS = 7; const BOARD_ROWS = 9;
        const WATER_TILES = [
            {x:1, y:3}, {x:2, y:3}, {x:4, y:3}, {x:5, y:3},
            {x:1, y:4}, {x:2, y:4}, {x:4, y:4}, {x:5, y:4},
            {x:1, y:5}, {x:2, y:5}, {x:4, y:5}, {x:5, y:5}
        ];
        const TRAPS = [
            {x:2, y:0, team:0}, {x:4, y:0, team:0}, {x:3, y:1, team:0},
            {x:2, y:8, team:1}, {x:4, y:8, team:1}, {x:3, y:7, team:1}
        ];
        const DENS = [{x:3, y:0, team:0}, {x:3, y:8, team:1}];
        
        const INITIAL_SETUP = [
            {x:0, y:0, t:0, r:7}, {x:6, y:0, t:0, r:6}, {x:1, y:1, t:0, r:3}, {x:5, y:1, t:0, r:2},
            {x:0, y:2, t:0, r:1}, {x:2, y:2, t:0, r:5}, {x:4, y:2, t:0, r:4}, {x:6, y:2, t:0, r:8},
            {x:6, y:8, t:1, r:7}, {x:0, y:8, t:1, r:6}, {x:5, y:7, t:1, r:3}, {x:1, y:7, t:1, r:2},
            {x:6, y:6, t:1, r:1}, {x:4, y:6, t:1, r:5}, {x:2, y:6, t:1, r:4}, {x:0, y:6, t:1, r:8}
        ];

        class GameEngine {
            constructor() { this.reset(); }
            reset() {
                this.board = Array(BOARD_COLS).fill(null).map(() => Array(BOARD_ROWS).fill(null));
                this.pieces = []; 
                // REGRA: O jogo agora comeÃ§a pela equipa Verde (1)
                this.currentTurn = 1; 
                this.winner = null;
            }
            addPiece(piece) { this.board[piece.gridX][piece.gridY] = piece; this.pieces.push(piece); }
            getPieceAt(x, y) { if (x < 0 || x >= BOARD_COLS || y < 0 || y >= BOARD_ROWS) return null; return this.board[x][y]; }
            isWater(x, y) { return WATER_TILES.some(w => w.x === x && w.y === y); }
            isTrap(x, y, team) { return TRAPS.some(t => t.x === x && t.y === y && t.team === team); }
            isDen(x, y, team) { return DENS.some(d => d.x === x && d.y === y && d.team === team); }

            isValidMove(piece, startX, startY, endX, endY) {
                if (this.winner !== null) return false;
                if (endX < 0 || endX >= BOARD_COLS || endY < 0 || endY >= BOARD_ROWS) return false;
                if (startX === endX && startY === endY) return false;
                if (this.isDen(endX, endY, piece.team)) return false;

                const targetPiece = this.getPieceAt(endX, endY);
                if (targetPiece && targetPiece.team === piece.team) return false;

                const dx = Math.abs(endX - startX), dy = Math.abs(endY - startY);
                const isOrthogonal = (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
                const endIsWater = this.isWater(endX, endY), startIsWater = this.isWater(startX, startY);

                if (isOrthogonal) {
                    if (endIsWater && piece.rank !== 1) return false;
                    return this.validateCapture(piece, targetPiece, startIsWater, endIsWater, endX, endY);
                }

                if ((piece.rank === 6 || piece.rank === 7) && this.isValidJump(startX, startY, endX, endY)) {
                    return this.validateCapture(piece, targetPiece, false, false, endX, endY);
                }
                return false;
            }

            isValidJump(startX, startY, endX, endY) {
                if (this.isWater(endX, endY)) return false;

                const dx = Math.abs(endX - startX), dy = Math.abs(endY - startY);
                if (!((dx > 1 && dy === 0) || (dx === 0 && dy > 1))) return false;
                const minX = Math.min(startX, endX), maxX = Math.max(startX, endX);
                const minY = Math.min(startY, endY), maxY = Math.max(startY, endY);

                if (dy === 0) {
                    for (let x = minX + 1; x < maxX; x++) {
                        if (!this.isWater(x, startY) || this.getPieceAt(x, startY) !== null) return false;
                    }
                    return true;
                } else {
                    for (let y = minY + 1; y < maxY; y++) {
                        if (!this.isWater(startX, y) || this.getPieceAt(startX, y) !== null) return false;
                    }
                    return true;
                }
            }

            validateCapture(piece, targetPiece, startIsWater, endIsWater, endX, endY) {
                if (!targetPiece) return true;
                if (startIsWater !== endIsWater) return false;
                if (this.isTrap(endX, endY, piece.team)) return true;
                if (piece.rank === 1 && targetPiece.rank === 8) return true;
                if (piece.rank === 8 && targetPiece.rank === 1) return false;
                return piece.rank >= targetPiece.rank;
            }

            executeMove(piece, endX, endY) {
                const startX = piece.gridX;
                const startY = piece.gridY;
                const targetPiece = this.getPieceAt(endX, endY);
                let captured = null;

                // 1. Clear the starting position
                this.board[startX][startY] = null;

                // 2. Handle capture
                if (targetPiece) {
                    captured = targetPiece;
                    this.pieces = this.pieces.filter(p => p !== targetPiece);
                }

                // 3. Update the piece's own coordinates
                piece.gridX = endX;
                piece.gridY = endY;

                // 4. Place the piece at the new position on the board
                this.board[endX][endY] = piece;

                // 5. Check for win condition and switch turns
                const enemyTeam = piece.team === 0 ? 1 : 0;
                if (this.isDen(endX, endY, enemyTeam) || this.pieces.filter(p => p.team === enemyTeam).length === 0) {
                    this.winner = piece.team;
                }
                this.currentTurn = enemyTeam;

                return captured;
            }
        }

        const engine = new GameEngine();

        // ==========================================
        // SISTEMA DE ÃUDIO ARCADE PROCEDURAL
        // ==========================================
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator(), gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            if (type === 'jump') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(250, now); osc.frequency.exponentialRampToValueAtTime(450, now + 0.2);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'squash') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            } else if (type === 'morph') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.3, now + 0.1); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'beep') {
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'beep-up') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'nervous') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(350, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.1); osc.frequency.linearRampToValueAtTime(380, now + 0.2);
                osc.frequency.linearRampToValueAtTime(300, now + 0.3); osc.frequency.linearRampToValueAtTime(350, now + 0.4);
                gain.gain.setValueAtTime(0.25, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            } else if (type === 'cheeky') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(500, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'win') {
                osc.type = 'square'; const notes = [261.63, 329.63, 392.00, 523.25, 392.00, 523.25, 659.25, 783.99, 1046.50]; let timeOffset = 0;
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.3, now + 0.05);
                notes.forEach((freq, index) => { osc.frequency.setValueAtTime(freq, now + timeOffset); timeOffset += (index >= notes.length - 2) ? 0.4 : 0.15; });
                gain.gain.setValueAtTime(0.3, now + timeOffset); gain.gain.linearRampToValueAtTime(0, now + timeOffset + 1.5);
                osc.start(now); osc.stop(now + timeOffset + 1.5);
            }
        }

        // ==========================================
        // THREE.JS SETUP & GRÃFICOS
        // ==========================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 8);
        scene.add(camera); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.xr.enabled = true; renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.getElementById('controls').appendChild(VRButton.createButton(renderer));
        document.getElementById('controls').appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0); controls.update();

        // ------------------------------------------
        // SISTEMA DE ILUMINAÃ‡ÃƒO SUTIL
        // ------------------------------------------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.45); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(5, 10, 5); dirLight.castShadow = true; scene.add(dirLight);

        const lightRedSide = new THREE.PointLight(0xffffff, 1.8, 15);
        lightRedSide.position.set(0, 2.5, -3.5); 
        scene.add(lightRedSide);

        const lightGreenSide = new THREE.PointLight(0xffffff, 1.8, 15);
        lightGreenSide.position.set(0, 2.5, 3.5); 
        scene.add(lightGreenSide);

        const auraLight = new THREE.PointLight(0xffffff, 0, 3.0);
        auraLight.position.y = 0.5;
        scene.add(auraLight);

        const gameGroup = new THREE.Group(); scene.add(gameGroup);

        // ==========================================
        // SISTEMA DE CENAS E UI 3D (MENUS)
        // ==========================================
        const menuGroup = new THREE.Group(); gameGroup.add(menuGroup);
        const optionsGroup = new THREE.Group(); gameGroup.add(optionsGroup);
        const aboutGroup = new THREE.Group(); gameGroup.add(aboutGroup);
        
        menuGroup.position.set(0, 2.5, 0);
        optionsGroup.position.set(0, 2.5, 0);
        aboutGroup.position.set(0, 2.5, 0);
        
        function createTextSprite(text, fontSize, width, height, color = 'white', bgColor = 'transparent') {
            const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            if (bgColor !== 'transparent') {
                ctx.fillStyle = bgColor;
                if (ctx.roundRect) ctx.roundRect(10, 10, width-20, height-20, 30); else ctx.fillRect(10, 10, width-20, height-20);
                ctx.fill(); ctx.lineWidth = 6; ctx.strokeStyle = '#ffffff'; ctx.stroke();
            }
            
            ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = `bold ${fontSize}px sans-serif`;
            
            const lines = text.split('\n');
            lines.forEach((line, i) => { ctx.fillText(line, width/2, height/2 + (i - (lines.length-1)/2) * fontSize * 1.2); });
            
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false }));
            sprite.scale.set(width/256, height/256, 1);
            return { sprite, ctx, canvas, material: sprite.material };
        }

        const titleSprite = createTextSprite("JUNGLE CHESS 3D", 100, 1024, 256, '#ffeb3b').sprite;
        titleSprite.position.y = 1.5; menuGroup.add(titleSprite);
        const btnSingle = createTextSprite("Jogar (Single-Player)", 50, 512, 128, 'white', '#4CAF50').sprite;
        btnSingle.position.y = 0.5; btnSingle.userData = { isMenuBtn: true, action: 'start_game' }; menuGroup.add(btnSingle);
        const btnMulti = createTextSprite("Multiplayer", 50, 512, 128, 'white', '#2196F3').sprite;
        btnMulti.position.y = -0.2; btnMulti.userData = { isMenuBtn: true, action: 'mock_multi' }; menuGroup.add(btnMulti);
        const btnOptions = createTextSprite("OpÃ§Ãµes", 50, 512, 128, 'white', '#9C27B0').sprite;
        btnOptions.position.y = -0.9; btnOptions.userData = { isMenuBtn: true, action: 'show_options' }; menuGroup.add(btnOptions);
        const btnAbout = createTextSprite("Sobre", 50, 512, 128, 'white', '#607D8B').sprite;
        btnAbout.position.y = -1.6; btnAbout.userData = { isMenuBtn: true, action: 'show_about' }; menuGroup.add(btnAbout);

        const optTitle = createTextSprite("OPÃ‡Ã•ES", 80, 512, 128, '#ffeb3b').sprite;
        optTitle.position.y = 1.0; optionsGroup.add(optTitle);
        const btnTipsObj = createTextSprite("Dicas e Ajuda: ON", 50, 512, 128, 'white', '#FF9800');
        const btnTips = btnTipsObj.sprite;
        btnTips.position.y = 0.0; btnTips.userData = { isMenuBtn: true, action: 'toggle_tips' }; optionsGroup.add(btnTips);
        const btnOptBack = createTextSprite("Voltar", 50, 512, 128, 'white', '#f44336').sprite;
        btnOptBack.position.y = -1.0; btnOptBack.userData = { isMenuBtn: true, action: 'show_menu' }; optionsGroup.add(btnOptBack);

        const abtTitle = createTextSprite("SOBRE", 80, 512, 128, '#ffeb3b').sprite;
        abtTitle.position.y = 1.5; aboutGroup.add(abtTitle);
        const abtText = createTextSprite("Jungle Chess 3D\n\nCriado com Three.js / WebXR\nUm clÃ¡ssico 'Dou Shou Qi' nostÃ¡lgico.", 40, 1024, 512, 'white').sprite;
        abtText.position.y = 0.0; aboutGroup.add(abtText);
        const btnAbtBack = createTextSprite("Voltar", 50, 512, 128, 'white', '#f44336').sprite;
        btnAbtBack.position.y = -1.5; btnAbtBack.userData = { isMenuBtn: true, action: 'show_menu' }; aboutGroup.add(btnAbtBack);

        function switchScene(newScene) {
            currentScene = newScene;
            const targetGameY = currentScene === 'game' ? 0 : -2.0;
            const targetGameScale = currentScene === 'game' ? 1.0 : 0.8;
            
            document.getElementById('ui-container').style.display = currentScene === 'game' ? 'flex' : 'none';
            hudGroup.visible = currentScene === 'game';

            menuGroup.visible = currentScene === 'menu';
            optionsGroup.visible = currentScene === 'options';
            aboutGroup.visible = currentScene === 'about';

            gameGroup.userData.targetY = targetGameY;
            gameGroup.userData.targetScale = targetGameScale;
        }

        // ==========================================
        // HUD ANCORADO NA CÃ‚MARA (Jogabilidade)
        // ==========================================
        const hudGroup = new THREE.Group();
        camera.add(hudGroup);

        function createHUDButton(text, color) {
            const { sprite } = createTextSprite(text, 45, 512, 128, 'white', color);
            sprite.scale.set(0.8, 0.2, 1);
            sprite.userData = { isHUDButton: true, action: text };
            hudGroup.add(sprite);
            return sprite;
        }

        const menuHudBtn = createHUDButton('â˜° MENU', '#9C27B0');
        const restartBtn = createHUDButton('ðŸ”„ REINICIAR', '#f44336');
        const inviteBtn = createHUDButton('ðŸ”— CONVIDAR', '#FF9800');

        function updateHUDPosition() {
            const dist = -2.5; 
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * Math.abs(dist);
            const width = height * camera.aspect;
            
            const rightEdge = (width / 2) - 0.5; 
            const topEdge = (height / 2) - 0.2; 
            
            menuHudBtn.position.set(rightEdge, topEdge, dist);
            restartBtn.position.set(rightEdge, topEdge - 0.25, dist);
            inviteBtn.position.set(rightEdge, topEdge - 0.50, dist);
        }
        updateHUDPosition();

        // ==========================================
        // TABULEIRO E MATERIAIS
        // ==========================================
        function createWaterTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4682B4'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#63b4f5'; ctx.lineWidth = 3;
            for (let y = -20; y < 300; y += 15) {
                ctx.beginPath();
                for (let x = 0; x <= 256; x += 15) ctx.lineTo(x, y + Math.sin(x * 0.1) * 6);
                ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        function createGrassTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#6B8E23'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#557519'; ctx.lineWidth = 3; ctx.lineCap = ctx.lineJoin = 'round';
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 256, y = Math.random() * 256, size = 6 + Math.random() * 8;
                ctx.beginPath(); ctx.moveTo(x - size, y + size); ctx.lineTo(x, y); ctx.lineTo(x + size, y + size); ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        function createDenTexture(bgColor) {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, 256, 256); ctx.lineCap = 'round';
            for (let i = 0; i < 100; i++) {
                ctx.strokeStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.6)' : 'rgba(100,60,30,0.8)';
                ctx.lineWidth = 2 + Math.random() * 3;
                const x1 = Math.random() * 256, y1 = Math.random() * 256;
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x1 + (Math.random() - 0.5) * 80, y1 + (Math.random() - 0.5) * 80); ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = tex.wrapT = THREE.RepeatWrapping; return tex;
        }

        const matLand = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createGrassTexture(), roughness: 0.9 });
        const matWater = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createWaterTexture(), roughness: 0.1, transparent: true, opacity: 0.85, flatShading: true });
        const matTrap = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createDenTexture('#DAA520'), roughness: 1.0 });
        const matDenRed = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createDenTexture('#8B0000'), roughness: 1.0 });
        const matDenGreen = new THREE.MeshStandardMaterial({ color: 0xffffff, map: createDenTexture('#006400'), roughness: 1.0 });

        const tileSize = 1; const tileSpacing = 0.05; const tileMeshes = [];

        function getWorldPos(gridX, gridY) { return new THREE.Vector3((gridX - BOARD_COLS/2 + 0.5) * tileSize, 0, (gridY - BOARD_ROWS/2 + 0.5) * tileSize); }

        const craterGeo = new THREE.TorusGeometry(0.28, 0.06, 4, 16);
        const trapTextGeo = new THREE.PlaneGeometry(0.7, 0.7);
        const trapObjMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });
        
        function createTrapTextTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FF0000'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 5; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 32px sans-serif';
            ctx.strokeText('TRAP', 64, 64); ctx.fillText('TRAP', 64, 64);
            const tex = new THREE.CanvasTexture(canvas); tex.center.set(0.5, 0.5); return tex;
        }
        const trapTextMat = new THREE.MeshBasicMaterial({ map: createTrapTextTexture(), transparent: true, opacity: 0.2, depthWrite: false });

        const tileGeo = new THREE.BoxGeometry(tileSize - tileSpacing, 0.2, tileSize - tileSpacing);
        const waterGeoBase = new THREE.BoxGeometry(tileSize - tileSpacing, 0.2, tileSize - tileSpacing, 5, 1, 5);

        for (let x = 0; x < BOARD_COLS; x++) {
            for (let y = 0; y < BOARD_ROWS; y++) {
                let mat = matLand; let geo = tileGeo;
                const isWater = engine.isWater(x, y), isTrap = engine.isTrap(x, y, 0) || engine.isTrap(x, y, 1);
                if (isWater) { mat = matWater; geo = waterGeoBase.clone(); }
                else if (isTrap) mat = matTrap; else if (engine.isDen(x, y, 0)) mat = matDenRed; else if (engine.isDen(x, y, 1)) mat = matDenGreen;

                const tile = new THREE.Mesh(geo, mat); const pos = getWorldPos(x, y); tile.position.copy(pos);
                if(isWater) tile.position.y -= 0.04; tile.receiveShadow = true;
                tile.userData = { isTile: true, gridX: x, gridY: y, isWater: isWater };

                if (isWater) {
                    tile.userData.originalVertices = []; const posAttr = geo.attributes.position;
                    for (let i = 0; i < posAttr.count; i++) tile.userData.originalVertices.push(new THREE.Vector3().fromBufferAttribute(posAttr, i));
                }
                gameGroup.add(tile); tileMeshes.push(tile);

                if (isTrap) {
                    const crater = new THREE.Mesh(craterGeo, trapObjMat);
                    crater.rotation.x = Math.PI / 2; crater.scale.z = 0.5; crater.position.set(pos.x, 0.12, pos.z);
                    gameGroup.add(crater);
                    const textPlane = new THREE.Mesh(trapTextGeo, trapTextMat);
                    textPlane.rotation.x = -Math.PI / 2; textPlane.position.set(pos.x, 0.11, pos.z);
                    gameGroup.add(textPlane);
                }
            }
        }
        const borderGeo = new THREE.BoxGeometry(BOARD_COLS + 0.2, 0.5, BOARD_ROWS + 0.2);
        const borderMat = new THREE.MeshStandardMaterial({ color: 0x3d2314 });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.y = -0.35; border.receiveShadow = true; gameGroup.add(border);

        // ==========================================
        // CILINDRO ARREDONDADO E MATERIAL "MASSINHA"
        // ==========================================
        function createPieceMaterial(rank, team) {
            const data = RANKS[rank], tData = TEAMS[team];
            const cTop = document.createElement('canvas'); cTop.width = cTop.height = 256; const ctxTop = cTop.getContext('2d');
            ctxTop.fillStyle = tData.color; ctxTop.fillRect(0, 0, 256, 256);
            ctxTop.fillStyle = '#fff'; ctxTop.textAlign = 'center'; ctxTop.textBaseline = 'middle'; ctxTop.font = 'bold 160px sans-serif';
            ctxTop.fillText(rank.toString(), 128, 140); ctxTop.strokeStyle = '#000'; ctxTop.lineWidth = 4; ctxTop.strokeText(rank.toString(), 128, 140);
            
            const cSide = document.createElement('canvas'); cSide.width = 1024; cSide.height = 280; const ctxSide = cSide.getContext('2d');
            ctxSide.fillStyle = tData.color; ctxSide.fillRect(0, 0, 1024, 280);
            ctxSide.fillStyle = '#fff'; ctxSide.textAlign = 'center'; ctxSide.textBaseline = 'middle'; ctxSide.font = 'bold 100px sans-serif';
            ctxSide.fillText(`${data.icon} ${data.name.toUpperCase()} ${data.icon}`, 512, 140);
            
            const texTop = new THREE.CanvasTexture(cTop); texTop.center.set(0.5, 0.5);
            const texSide = new THREE.CanvasTexture(cSide);
            
            const matConfig = { roughness: 0.6, metalness: 0.1, clearcoat: 0.3, clearcoatRoughness: 0.8 };
            return [
                new THREE.MeshPhysicalMaterial({ map: texSide, ...matConfig }), // Lado
                new THREE.MeshPhysicalMaterial({ map: texTop, ...matConfig }),  // Top
                new THREE.MeshPhysicalMaterial({ color: tData.color, ...matConfig }) // Fundo
            ];
        }

        function createEmojiSprite(rank) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '280px sans-serif'; 
            ctx.shadowColor = 'rgba(255, 255, 100, 1.0)'; ctx.shadowBlur = 60;
            ctx.fillText(RANKS[rank].icon, 256, 280);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
            sprite.scale.set(1.5, 1.5, 1); sprite.position.y = 0.4;
            return sprite;
        }

        let activeParticles = [];
        function spawnCustomParticles(emojis, pos, count = 20) {
            for(let i=0; i<count; i++) {
                const emoji = emojis[Math.floor(Math.random() * emojis.length)];
                const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d'); ctx.font = '60px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(emoji, 64, 64);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 1 }));
                sprite.position.copy(pos); sprite.position.y = 1.0; 
                
                const angle = Math.random() * Math.PI * 2, speed = 1 + Math.random() * 3, velY = 3 + Math.random() * 5;
                gameGroup.add(sprite);
                activeParticles.push({ mesh: sprite, vx: Math.cos(angle) * speed, vy: velY, vz: Math.sin(angle) * speed, life: 1.0 });
            }
        }

        function spawnVictoryParticles(rank, pos) { spawnCustomParticles(PARTICLE_EMOJIS[rank], pos, 40); }

        function updatePieceTopNumber(pd, text) {
            const material = pd.cylinder.material[1];
            const canvas = material.map.image; const ctx = canvas.getContext('2d');
            ctx.fillStyle = TEAMS[pd.team].color; ctx.fillRect(0, 0, 256, 256);
            ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 160px sans-serif';
            ctx.fillText(text, 128, 140); ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeText(text, 128, 140);
            material.map.needsUpdate = true;
        }

        function createRoundedCylinder(radius, height, radialSegments, filletRadius, filletSegments) {
            const points = []; points.push(new THREE.Vector2(0, -height/2));
            for(let i=0; i<=filletSegments; i++) { const a = (i/filletSegments) * (Math.PI/2); points.push(new THREE.Vector2(radius - filletRadius + Math.sin(a)*filletRadius, -height/2 + filletRadius - Math.cos(a)*filletRadius)); }
            for(let i=0; i<=filletSegments; i++) { const a = (i/filletSegments) * (Math.PI/2); points.push(new THREE.Vector2(radius - filletRadius + Math.cos(a)*filletRadius, height/2 - filletRadius + Math.sin(a)*filletRadius)); }
            points.push(new THREE.Vector2(0, height/2));
            const geo = new THREE.LatheGeometry(points, radialSegments);
            geo.rotateY(-Math.PI / 2); geo.computeVertexNormals();
            const pos = geo.attributes.position, uv = geo.attributes.uv;
            for(let i=0; i<uv.count; i++) {
                const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
                if (y > height/2 - 0.001) uv.setXY(i, 0.5 + x/(radius*2), 0.5 - z/(radius*2));
                else if (y < -height/2 + 0.001) uv.setXY(i, 0.5 + x/(radius*2), 0.5 + z/(radius*2));
                else { let v = (y - (-height/2 + filletRadius)) / (height - 2*filletRadius); uv.setY(i, Math.max(0, Math.min(1, v))); }
            }
            geo.clearGroups(); let currentMat = -1, groupStart = 0, groupCount = 0; const index = geo.index;
            for (let i = 0; i < index.count; i += 3) {
                const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2), avgY = (pos.getY(a) + pos.getY(b) + pos.getY(c)) / 3;
                let matIdx = 0; if (avgY > height/2 - 0.001) matIdx = 1; else if (avgY < -height/2 + 0.001) matIdx = 2; 
                if (matIdx !== currentMat) { if (currentMat !== -1) geo.addGroup(groupStart, groupCount, currentMat); currentMat = matIdx; groupStart = i; groupCount = 3; } else groupCount += 3;
            }
            if (groupCount > 0) geo.addGroup(groupStart, groupCount, currentMat);
            return geo;
        }

        const pieceGeo = createRoundedCylinder(0.35, 0.6, 32, 0.08, 6);
        const hitBoxGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.6);
        const hitBoxMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false });

        let pieceMeshes = [];

        function initPieces() {
            pieceMeshes.forEach(p => gameGroup.remove(p.mesh)); pieceMeshes = [];
            activeParticles.forEach(p => gameGroup.remove(p.mesh)); activeParticles = [];
            engine.reset();

            INITIAL_SETUP.forEach(setup => {
                const pos = getWorldPos(setup.x, setup.y);
                const group = new THREE.Group(); 
                group.position.set(pos.x, 0.4, pos.z);
                const mats = createPieceMaterial(setup.r, setup.t);
                const cylinder = new THREE.Mesh(pieceGeo, mats);
                cylinder.castShadow = true; cylinder.receiveShadow = true; cylinder.rotation.y = setup.t === 0 ? 0 : Math.PI;
                group.add(cylinder);
                const sprite = createEmojiSprite(setup.r); sprite.visible = false; group.add(sprite);
                const hitBox = new THREE.Mesh(hitBoxGeo, hitBoxMat);
                const pieceData = {
                    gridX: setup.x, gridY: setup.y, team: setup.t, rank: setup.r,
                    mesh: group, cylinder: cylinder, sprite: sprite, startPos: group.position.clone(), targetPos: group.position.clone(),
                    isMoving: false, moveProgress: 0, squashTimer: 0, capturedPiece: null, isVictoryPending: false,
                    isDying: false, isDead: false, isMorphing: false, morphTimer: 0, isBigAnim: false, captureAnimTimer: 0,
                    trapAnimState: 0, trapNumberVisual: setup.r, trapTimer: 0, isInDanger: false,
                    baseTeamColor: new THREE.Color(TEAMS[setup.t].color)
                };
                hitBox.userData = { isPiece: true, pieceData: pieceData };
                group.add(hitBox);
                gameGroup.add(group); pieceMeshes.push(pieceData); engine.addPiece(pieceData);
            });
            updateStatusUI();
        }
        initPieces(); 

        const highlightGeo = new THREE.RingGeometry(0.3, 0.4, 32); highlightGeo.rotateX(-Math.PI / 2);
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
        const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat); highlightMesh.position.y = 0.15; highlightMesh.visible = false;
        gameGroup.add(highlightMesh);

        let selectedPiece = null;
        const validHighlightMeshes = [];

        function showValidMoves(piece) {
            clearHighlights();
            const playerColor = TEAMS[piece.team].color;
            for(let x=0; x<BOARD_COLS; x++) {
                for(let y=0; y<BOARD_ROWS; y++) {
                    if(engine.isValidMove(piece, piece.gridX, piece.gridY, x, y)) {
                        const hl = new THREE.Mesh(highlightGeo, new THREE.MeshBasicMaterial({color: playerColor, transparent: true, opacity: 0.7}));
                        const pos = getWorldPos(x, y); hl.position.set(pos.x, 0.15, pos.z);
                        hl.userData = { isTile: true, gridX: x, gridY: y };
                        gameGroup.add(hl); validHighlightMeshes.push(hl);
                    }
                }
            }
        }

        function clearHighlights() { highlightMesh.visible = false; validHighlightMeshes.forEach(h => gameGroup.remove(h)); validHighlightMeshes.length = 0; }
        function updateStatusUI() {
            const statusEl = document.getElementById('status');
            if (engine.winner !== null) {
                statusEl.textContent = `Vencedor: Jogador ${TEAMS[engine.winner].name}!`;
                statusEl.style.color = '#fff'; statusEl.style.background = '#4CAF50'; statusEl.style.padding = '5px';
            } else {
                statusEl.textContent = `Turno do Jogador ${TEAMS[engine.currentTurn].name}`;
                statusEl.style.color = TEAMS[engine.currentTurn].color; statusEl.style.background = 'none';
            }
        }

        function handleMenuInteraction(obj) {
            playSound('beep-up');
            obj.scale.y *= 0.7; setTimeout(() => obj.scale.y /= 0.7, 150);
            const action = obj.userData.action;
            if (action === 'start_game') { initPieces(); switchScene('game'); } 
            else if (action === 'show_options') { switchScene('options'); } 
            else if (action === 'show_about') { switchScene('about'); } 
            else if (action === 'show_menu') { switchScene('menu'); } 
            else if (action === 'toggle_tips') {
                tipsEnabled = !tipsEnabled;
                const newText = tipsEnabled ? "Dicas e Ajuda: ON" : "Dicas e Ajuda: OFF";
                const bgColor = tipsEnabled ? "#FF9800" : "#757575";
                const { canvas, ctx } = btnTipsObj;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = bgColor;
                if (ctx.roundRect) ctx.roundRect(10, 10, canvas.width-20, canvas.height-20, 30); else ctx.fillRect(10, 10, canvas.width-20, canvas.height-20);
                ctx.fill(); ctx.lineWidth = 6; ctx.strokeStyle = '#ffffff'; ctx.stroke();
                ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = 'bold 50px sans-serif'; ctx.fillText(newText, canvas.width/2, canvas.height/2);
                btnTipsObj.material.map.needsUpdate = true;
            } else if (action === 'mock_multi') {
                const mat = obj.material; mat.color.setHex(0x555555); setTimeout(() => mat.color.setHex(0xffffff), 1000);
            }
        }

        function handleInteraction(intersection) {
            const obj = intersection.object;
            if (obj.userData.isMenuBtn) { handleMenuInteraction(obj); return; }
            if (obj.userData.isHUDButton) {
                playSound('beep-up');
                obj.scale.set(0.7, 0.15, 1); setTimeout(() => obj.scale.set(0.8, 0.2, 1), 150);
                if (obj.userData.action === 'â˜° MENU') { switchScene('menu'); } 
                else if (obj.userData.action === 'ðŸ”„ REINICIAR') { initPieces(); selectedPiece = null; clearHighlights(); } 
                else {
                    const statusEl = document.getElementById('status');
                    statusEl.textContent = "âš™ï¸ Em Breve..."; statusEl.style.color = "#FF9800";
                    setTimeout(() => updateStatusUI(), 1500);
                }
                return;
            }
            if (currentScene !== 'game' || engine.winner !== null) return;
            if (obj.userData.isPiece) {
                const pd = obj.userData.pieceData;
                if (!pd.isDead && !pd.isVictoryPending && !pd.isMoving && !pd.isBigAnim && pd.trapAnimState === 0) {
                    pd.isMorphing = true; pd.morphTimer = 1.0; playSound('morph');
                }
                if (pd.team === engine.currentTurn) {
                    if (selectedPiece && selectedPiece !== pd) selectedPiece.targetPos.y = 0.4;
                    selectedPiece = pd; selectedPiece.targetPos.y = 0.5;
                    highlightMesh.position.copy(getWorldPos(pd.gridX, pd.gridY));
                    highlightMesh.position.y = 0.15; highlightMesh.visible = true;
                    showValidMoves(pd);
                } else if (selectedPiece) { tryMove(pd.gridX, pd.gridY); }
            } else if (obj.userData.isTile && selectedPiece) { tryMove(obj.userData.gridX, obj.userData.gridY); }
        }

        function tryMove(endX, endY) {
            if (engine.isValidMove(selectedPiece, selectedPiece.gridX, selectedPiece.gridY, endX, endY)) {
                const captured = engine.executeMove(selectedPiece, endX, endY);
                const targetWorld = getWorldPos(endX, endY);
                if (selectedPiece.trapAnimState > 0) selectedPiece.trapAnimState = 0;
                selectedPiece.startPos = selectedPiece.mesh.position.clone();
                selectedPiece.targetPos = new THREE.Vector3(targetWorld.x, 0.4, targetWorld.z);
                selectedPiece.isMoving = true; selectedPiece.moveProgress = 0;
                selectedPiece.isMorphing = false; selectedPiece.isBigAnim = false; selectedPiece.cylinder.visible = true;
                selectedPiece.capturedPiece = captured; selectedPiece.isVictoryPending = (engine.winner !== null);
                playSound('jump'); selectedPiece = null; clearHighlights(); updateStatusUI();
            } else { if (selectedPiece) selectedPiece.targetPos.y = 0.4; selectedPiece = null; clearHighlights(); }
        }

        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        function onPointerDown(event) {
            initAudio(); 
            if (renderer.xr.isPresenting || event.target.tagName === 'BUTTON') return;
            if (event.touches && event.touches.length > 1) {
                return; // Managed by touch zoom handlers
            }
            if (event.changedTouches) {
                mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.changedTouches[0].clientY / window.innerHeight) * 2 + 1;
            } else {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            raycaster.setFromCamera(mouse, camera);
            let intersectables = [];
            if (currentScene === 'menu') intersectables = menuGroup.children;
            else if (currentScene === 'options') intersectables = optionsGroup.children;
            else if (currentScene === 'about') intersectables = aboutGroup.children;
            else if (currentScene === 'game') intersectables = [...gameGroup.children, ...hudGroup.children];
            const intersects = raycaster.intersectObjects(intersectables, true)
                .filter(hit => {
                    const ud = hit.object.userData; if (!ud) return false;
                    if (currentScene === 'game') return (ud.isPiece && ud.pieceData && !ud.pieceData.isDead) || ud.isTile || ud.isHUDButton;
                    else return ud.isMenuBtn;
                });
            if (intersects.length > 0) handleInteraction(intersects[0]);
            else if (selectedPiece && currentScene === 'game') { selectedPiece.targetPos.y = 0.4; selectedPiece = null; clearHighlights(); }
        }
        window.addEventListener('pointerdown', onPointerDown);

        // Pinch-to-zoom logic for touch devices
        let isPinching = false;
        let initialPinchDistance = 0;
        const initialGameScale = new THREE.Vector3();

        function onTouchStart(event) {
            if (renderer.xr.isPresenting && event.touches.length === 2) {
                event.preventDefault();
                const t1 = event.touches[0];
                const t2 = event.touches[1];
                initialPinchDistance = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
                initialGameScale.copy(gameGroup.scale);
                isPinching = true;
            }
        }

        function onTouchMove(event) {
            if (isPinching && event.touches.length === 2) {
                event.preventDefault();
                const t1 = event.touches[0];
                const t2 = event.touches[1];
                const currentPinchDistance = Math.hypot(t1.pageX - t2.pageX, t1.pageY - t2.pageY);
                const scaleFactor = currentPinchDistance / initialPinchDistance;
                const newScale = initialGameScale.clone().multiplyScalar(scaleFactor);
                // Clamp the scale to reasonable values
                newScale.clampScalar(0.1, 2.0);
                gameGroup.scale.copy(newScale);
            }
        }

        function onTouchEnd(event) {
            if (isPinching) {
                isPinching = false;
                // Persist the zoom level after pinching
                gameGroup.userData.targetScale = gameGroup.scale.x;
            }
        }

        window.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchend', onTouchEnd);


        let hitTestSource = null, hitTestSourceRequested = false, reticle, isARPlaced = false, isARSession = false;
        reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        reticle.matrixAutoUpdate = false; reticle.visible = false; scene.add(reticle);

        const controller1 = renderer.xr.getController(0), controller2 = renderer.xr.getController(1);
        scene.add(controller1); scene.add(controller2);
        const controllerModelFactory = new XRControllerModelFactory();
        const grip1 = renderer.xr.getControllerGrip(0); grip1.add(controllerModelFactory.createControllerModel(grip1)); scene.add(grip1);
        const grip2 = renderer.xr.getControllerGrip(1); grip2.add(controllerModelFactory.createControllerModel(grip2)); scene.add(grip2);
        const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
        const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffffff })); line.name = 'line'; line.scale.z = 5;
        controller1.add(line.clone()); controller2.add(line.clone());

        // VR controller zoom logic
        let controller1Selected = false, controller2Selected = false, isZoomingVR = false;
        let initialControllerDist = 0;
        const initialGameScaleVR = new THREE.Vector3();

        controller1.addEventListener('selectstart', () => { controller1Selected = true; });
        controller1.addEventListener('selectend', () => {
            controller1Selected = false;
            if (isZoomingVR) {
                // Persist the zoom level after VR zoom
                gameGroup.userData.targetScale = gameGroup.scale.x;
            }
            isZoomingVR = false;
        });
        controller2.addEventListener('selectstart', () => { controller2Selected = true; });
        controller2.addEventListener('selectend', () => {
            controller2Selected = false;
            if (isZoomingVR) {
                // Persist the zoom level after VR zoom
                gameGroup.userData.targetScale = gameGroup.scale.x;
            }
            isZoomingVR = false;
        });


        function onSelectXR(event) {
            initAudio(); const controller = event.target;
            if (controller1Selected && controller2Selected) return; // Don't interact if zooming

            if (isARSession && !isARPlaced) {
                if (reticle.visible) {
                    const arPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
                    arPos.y -= 0.2; // Lower the board slightly
                    gameGroup.position.copy(arPos);
                    gameGroup.scale.set(0.3, 0.3, 0.3);
                    isARPlaced = true; reticle.visible = false; document.getElementById('ar-overlay').style.display = 'none';
                }
                return;
            }
            const tempMatrix = new THREE.Matrix4(); tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            let intersectables = [];
            if (currentScene === 'menu') intersectables = menuGroup.children;
            else if (currentScene === 'options') intersectables = optionsGroup.children;
            else if (currentScene === 'about') intersectables = aboutGroup.children;
            else if (currentScene === 'game') intersectables = [...gameGroup.children, ...hudGroup.children];
            const intersects = raycaster.intersectObjects(intersectables, true)
                .filter(hit => {
                    const ud = hit.object.userData; if (!ud) return false;
                    if (currentScene === 'game') return (ud.isPiece && ud.pieceData && !ud.pieceData.isDead) || ud.isTile || ud.isHUDButton;
                    else return ud.isMenuBtn;
                });
            if (intersects.length > 0) handleInteraction(intersects[0]);
        }
        controller1.addEventListener('select', onSelectXR); controller2.addEventListener('select', onSelectXR);
        
        renderer.xr.addEventListener('sessionstart', (e) => {
            isARSession = renderer.xr.getSession().mode === 'immersive-ar';
            if (isARSession) { document.getElementById('ar-overlay').style.display = 'block'; gameGroup.position.set(0, -1000, 0); isARPlaced = false; }
            else { gameGroup.position.set(0, 1, -2); gameGroup.scale.set(0.5, 0.5, 0.5); }
        });
        renderer.xr.addEventListener('sessionend', () => {
            isARSession = false; hitTestSourceRequested = false; hitTestSource = null;
            document.getElementById('ar-overlay').style.display = 'none';
            gameGroup.position.set(0,0,0); gameGroup.scale.set(1,1,1);
        });

        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            updateHUDPosition(); 
        });

        switchScene('menu'); 
        gameGroup.userData.targetY = gameGroup.position.y;
        gameGroup.userData.targetScale = gameGroup.scale.y;

        const clock = new THREE.Clock();
        const emissiveOff = new THREE.Color(0x000000);

        function animate() { renderer.setAnimationLoop(render); }

        function render(timestamp, frame) {
            const delta = clock.getDelta(); const time = clock.getElapsedTime();
            
            // Handle VR zoom
            if (controller1Selected && controller2Selected) {
                if (!isZoomingVR) {
                    isZoomingVR = true;
                    initialControllerDist = grip1.position.distanceTo(grip2.position);
                    initialGameScaleVR.copy(gameGroup.scale);
                }
                const currentDist = grip1.position.distanceTo(grip2.position);
                if (initialControllerDist > 0.01) { // Avoid division by zero
                    const scaleFactor = currentDist / initialControllerDist;
                    const newScale = initialGameScaleVR.clone().multiplyScalar(scaleFactor);
                    newScale.clampScalar(0.1, 2.0); // Clamp scale
                    gameGroup.scale.copy(newScale);
                }
            } else {
                isZoomingVR = false;
            }


            if (!isPinching && !isZoomingVR) { // Only lerp scale if not actively zooming
                const s = THREE.MathUtils.lerp(gameGroup.scale.y, gameGroup.userData.targetScale, 4 * delta);
                if (Math.abs(s - gameGroup.userData.targetScale) > 0.001) {
                    gameGroup.scale.set(s,s,s);
                }
            }
            gameGroup.position.y = THREE.MathUtils.lerp(gameGroup.position.y, gameGroup.userData.targetY, 4 * delta);
            

            const targetRedLight = engine.currentTurn === 0 ? 6.0 : 1.8;
            const targetGreenLight = engine.currentTurn === 1 ? 6.0 : 1.8;
            lightRedSide.intensity = THREE.MathUtils.lerp(lightRedSide.intensity, targetRedLight, delta * 4);
            lightGreenSide.intensity = THREE.MathUtils.lerp(lightGreenSide.intensity, targetGreenLight, delta * 4);

            if (selectedPiece && currentScene === 'game') {
                auraLight.intensity = THREE.MathUtils.lerp(auraLight.intensity, 4.0, delta * 10);
                auraLight.color.copy(selectedPiece.baseTeamColor);
                auraLight.position.x = THREE.MathUtils.lerp(auraLight.position.x, selectedPiece.mesh.position.x, delta * 15);
                auraLight.position.z = THREE.MathUtils.lerp(auraLight.position.z, selectedPiece.mesh.position.z, delta * 15);
            } else { auraLight.intensity = THREE.MathUtils.lerp(auraLight.intensity, 0, delta * 10); }

            tileMeshes.forEach(tile => {
                if (tile.userData.isWater) {
                    const posAttr = tile.geometry.attributes.position, origVerts = tile.userData.originalVertices;
                    const worldX = tile.position.x, worldZ = tile.position.z;
                    for (let i = 0; i < posAttr.count; i++) {
                        const origP = origVerts[i];
                        if (origP.y > 0.05) {
                            const wave = Math.sin((worldX + origP.x) * 3 + time * 2) * 0.04 + Math.cos((worldZ + origP.z) * 3 + time * 1.5) * 0.04;
                            posAttr.setY(i, origP.y + wave);
                        }
                    }
                    posAttr.needsUpdate = true; tile.geometry.computeVertexNormals();
                }
            });

            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const p = activeParticles[i];
                p.mesh.position.x += p.vx * delta; p.mesh.position.y += p.vy * delta; p.mesh.position.z += p.vz * delta;
                p.vy -= 15.0 * delta; p.life -= delta * 0.5; p.mesh.material.opacity = p.life;
                if (p.life <= 0) { gameGroup.remove(p.mesh); activeParticles.splice(i, 1); }
            }

            const camAngle = Math.atan2(camera.position.x, camera.position.z);
            const snapAngle = Math.round(camAngle / (Math.PI / 2)) * (Math.PI / 2);
            trapTextMat.map.rotation = snapAngle;
            
            [menuGroup, optionsGroup, aboutGroup].forEach(grp => {
                if(grp.visible) { grp.lookAt(camera.position); grp.position.y = 2.5 + Math.sin(time * 2) * 0.1; }
            });

            pieceMeshes.forEach(pd => {
                if (pd.isDead) return;
                if (pd.isMoving) {
                    pd.moveProgress += delta * 2.5;
                    if (pd.moveProgress >= 1.0) {
                        pd.moveProgress = 1.0; pd.isMoving = false; pd.squashTimer = 1.0; 
                        if (pd.capturedPiece) { pd.capturedPiece.isDying = true; playSound('squash'); pd.captureAnimTimer = 0.3; } else if (pd.isVictoryPending) { pd.captureAnimTimer = 0.1; }
                        const enemyTeam = pd.team === 0 ? 1 : 0;
                        if (engine.isTrap(pd.gridX, pd.gridY, enemyTeam)) {
                            if (pd.trapNumberVisual > 0) { pd.trapAnimState = 1; pd.trapTimer = 0.15; pd.isInDanger = engine.pieces.some(enemy => enemy.team === enemyTeam && engine.isValidMove(enemy, enemy.gridX, enemy.gridY, pd.gridX, pd.gridY)); }
                        } else if (pd.trapNumberVisual < pd.rank) { pd.trapAnimState = 3; pd.trapTimer = 0.15; }
                    }
                    const t = pd.moveProgress; const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                    const yOffset = Math.sin(t * Math.PI) * 1.2;
                    pd.mesh.position.lerpVectors(pd.startPos, pd.targetPos, easeT); pd.mesh.position.y += yOffset;
                    const stretch = 1.0 + Math.abs(Math.cos(t * Math.PI)) * 0.4;
                    pd.mesh.scale.set(1.0 / Math.sqrt(stretch), stretch, 1.0 / Math.sqrt(stretch));
                } else if (pd.squashTimer > 0) {
                    pd.squashTimer -= delta * 6.0; if (pd.squashTimer < 0) pd.squashTimer = 0;
                    const wobble = Math.sin(pd.squashTimer * Math.PI * 5) * pd.squashTimer * 0.4;
                    pd.mesh.scale.set(1.0 + wobble, 1.0 - wobble, 1.0 + wobble);
                } else if (pd.isDying) {
                    pd.mesh.scale.y = THREE.MathUtils.lerp(pd.mesh.scale.y, 0.05, 15 * delta);
                    pd.mesh.scale.x = THREE.MathUtils.lerp(pd.mesh.scale.x, 2.0, 15 * delta);
                    pd.mesh.scale.z = THREE.MathUtils.lerp(pd.mesh.scale.z, 2.0, 15 * delta);
                    if (pd.mesh.scale.y < 0.08) {
                        pd.mesh.visible = false;
                        pd.isDying = false;
                        pd.isDead = true;
                        // PHANTOM PIECE FIX: If the board still has a reference to this dead piece, remove it.
                        if (engine.getPieceAt(pd.gridX, pd.gridY) === pd) {
                            engine.board[pd.gridX][pd.gridY] = null;
                        }
                    }
                } else { // This block handles pieces at rest (not moving, squashing, or dying)
                    pd.mesh.scale.set(1, 1, 1);
                    
                    // Default behavior for pieces on land or pieces that aren't rats
                    if (pd.rank !== 1 || !engine.isWater(pd.gridX, pd.gridY)) {
                        pd.mesh.position.lerp(pd.targetPos, 10 * delta);
                        // Lerp rotation back to neutral
                        pd.mesh.rotation.x = THREE.MathUtils.lerp(pd.mesh.rotation.x, 0, delta * 5);
                        pd.mesh.rotation.z = THREE.MathUtils.lerp(pd.mesh.rotation.z, 0, delta * 5);
                    } else { // Custom buoyancy for rats on water
                        const wave = Math.sin(pd.mesh.position.x * 2.5 + time * 2.2) * 0.05 + Math.cos(pd.mesh.position.z * 2.5 + time * 1.8) * 0.05;
                        const floatingY = 0.25 + wave;
                        
                        // Lerp X and Z to the target, but use the wave for Y
                        const targetPosWithWave = new THREE.Vector3(pd.targetPos.x, floatingY, pd.targetPos.z);
                        pd.mesh.position.lerp(targetPosWithWave, 4 * delta);

                        // Add bobbing rotation
                        const targetRotX = Math.cos(time * 1.8 + pd.mesh.position.z * 2) * 0.25;
                        const targetRotZ = Math.sin(time * 2.2 + pd.mesh.position.x * 2) * 0.25;
                        pd.mesh.rotation.x = THREE.MathUtils.lerp(pd.mesh.rotation.x, targetRotX, delta * 4);
                        pd.mesh.rotation.z = THREE.MathUtils.lerp(pd.mesh.rotation.z, targetRotZ, delta * 4);
                    }
                }

                if (pd.trapAnimState === 1) {
                    pd.trapTimer -= delta;
                    if (pd.trapTimer <= 0) {
                        pd.trapNumberVisual--;
                        if (pd.trapNumberVisual >= 0) { updatePieceTopNumber(pd, pd.trapNumberVisual.toString()); playSound('beep'); pd.trapTimer = 0.15; } else {
                            pd.trapAnimState = 2; pd.isMorphing = true; pd.isBigAnim = false; pd.morphTimer = 2.0;
                            if (pd.isInDanger) { playSound('nervous'); spawnCustomParticles(['ðŸ’§', 'ðŸ˜°', 'ðŸ˜±', 'â—'], pd.targetPos, 15); } 
                            else { playSound('cheeky'); spawnCustomParticles(['ðŸ˜ˆ', 'ðŸ˜¼', 'ðŸ”¥', 'ðŸŽµ'], pd.targetPos, 15); }
                        }
                    }
                } else if (pd.trapAnimState === 2) { if (!pd.isMorphing) pd.trapAnimState = 0; } else if (pd.trapAnimState === 3) {
                    pd.trapTimer -= delta;
                    if (pd.trapTimer <= 0) {
                        pd.trapNumberVisual++;
                        if (pd.trapNumberVisual <= pd.rank) { updatePieceTopNumber(pd, pd.trapNumberVisual.toString()); playSound('beep-up'); pd.trapTimer = 0.15; } else { pd.trapNumberVisual = pd.rank; pd.trapAnimState = 0; }
                    }
                }

                if (pd.captureAnimTimer > 0) {
                    pd.captureAnimTimer -= delta;
                    if (pd.captureAnimTimer <= 0) {
                        pd.captureAnimTimer = 0; pd.isMorphing = true; pd.isBigAnim = true;
                        pd.morphTimer = pd.isVictoryPending ? Infinity : 2.5;
                        playSound('win'); spawnVictoryParticles(pd.rank, pd.targetPos);
                    }
                }

                if (pd.isMorphing && !pd.isDying && !pd.isMoving) {
                    pd.morphTimer -= delta;
                    if (pd.isBigAnim) { pd.cylinder.visible = false; pd.sprite.visible = true; pd.sprite.position.y = 1.5 + Math.sin(time * 6) * 0.1; pd.sprite.scale.lerp(new THREE.Vector3(3.5, 3.5, 1), 4 * delta); } 
                    else { pd.cylinder.visible = true; pd.sprite.visible = true; pd.sprite.position.y = 1.0 + Math.sin(time * 6) * 0.1; pd.sprite.scale.set(1.0, 1.0, 1); }
                    if (pd.morphTimer <= 0 && !pd.isVictoryPending) { pd.isMorphing = false; pd.isBigAnim = false; pd.sprite.visible = false; pd.cylinder.visible = true; }
                } else if (!pd.isVictoryPending) {
                    pd.sprite.scale.set(1.5, 1.5, 1);
                    if (!pd.isDying && !pd.isBigAnim) { pd.cylinder.visible = true; pd.sprite.visible = false; }
                }
                if (!pd.isMorphing && !pd.isDying && !pd.isDead) pd.cylinder.material[1].map.rotation = snapAngle - pd.cylinder.rotation.y;
                if (!pd.isDead && pd.cylinder && pd.cylinder.material) {
                    const isActiveTurn = (pd.team === engine.currentTurn);
                    const isSelected = (pd === selectedPiece);
                    const targetEmissive = new THREE.Color();
                    if (isSelected) {
                        targetEmissive.copy(pd.baseTeamColor).multiplyScalar(0.15);
                    } else if (isActiveTurn) {
                        targetEmissive.copy(pd.baseTeamColor).multiplyScalar(0.12);
                    } else { targetEmissive.copy(emissiveOff); }
                    pd.cylinder.material[0].emissive.lerp(targetEmissive, delta * 10);
                    pd.cylinder.material[1].emissive.lerp(targetEmissive, delta * 10);
                    pd.cylinder.material[2].emissive.lerp(targetEmissive, delta * 10);
                }
            });

            if (frame && isARSession && !isARPlaced) {
                const referenceSpace = renderer.xr.getReferenceSpace(), session = renderer.xr.getSession();
                if (!hitTestSourceRequested) { session.requestReferenceSpace('viewer').then((referenceSpace) => { session.requestHitTestSource({ space: referenceSpace }).then((source) => { hitTestSource = source; }); }); session.addEventListener('end', () => { hitTestSourceRequested = false; hitTestSource = null; }); hitTestSourceRequested = true; }
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) { reticle.visible = true; reticle.matrix.fromArray(hitTestResults[0].getPose(referenceSpace).transform.matrix); } 
                    else reticle.visible = false;
                }
            }
            controls.update(); renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>